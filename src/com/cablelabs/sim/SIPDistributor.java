/*
######################################################################################
##                                                                                  ##
## (c) 2006-2012 Cable Television Laboratories, Inc.  All rights reserved.  Any use ##
## of this documentation/package is subject to the terms and conditions of the      ##
## CableLabs License provided to you on download of the documentation/package.      ##
##                                                                                  ##
######################################################################################


*/
package com.cablelabs.sim;

import gov.nist.javax.sip.address.GenericURI;

import java.util.Enumeration;
import java.util.EventObject;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;

import javax.sip.ListeningPoint;
import javax.sip.RequestEvent;
import javax.sip.ResponseEvent;
import javax.sip.SipFactory;
import javax.sip.SipListener;
import javax.sip.SipProvider;
import javax.sip.SipStack;
import javax.sip.address.AddressFactory;
import javax.sip.address.SipURI;
import javax.sip.address.TelURL;
import javax.sip.address.URI;
import javax.sip.header.CSeqHeader;
import javax.sip.header.CallIdHeader;
import javax.sip.header.ContactHeader;
import javax.sip.header.ContentDispositionHeader;
import javax.sip.header.ContentTypeHeader;
import javax.sip.header.EventHeader;
import javax.sip.header.FromHeader;
import javax.sip.header.HeaderFactory;
import javax.sip.header.RecordRouteHeader;
import javax.sip.header.RequireHeader;
import javax.sip.header.RouteHeader;
import javax.sip.header.SupportedHeader;
import javax.sip.header.ToHeader;
import javax.sip.message.Message;
import javax.sip.message.MessageFactory;
import javax.sip.message.Request;
import javax.sip.message.Response;

import com.cablelabs.common.Conversion;
import com.cablelabs.common.Transport;
import com.cablelabs.fsm.FSMListener;
import com.cablelabs.fsm.MsgEvent;
import com.cablelabs.fsm.MsgQueue;
import com.cablelabs.fsm.MsgRef;
import com.cablelabs.fsm.NetworkElements;
import com.cablelabs.fsm.Proxy;
import com.cablelabs.fsm.Retransmit;
import com.cablelabs.fsm.SIPConstants;
import com.cablelabs.fsm.SIPMsg;
import com.cablelabs.fsm.Send;
import com.cablelabs.fsm.SettingConstants;
import com.cablelabs.fsm.SystemSettings;
import com.cablelabs.fsm.UtilityMsg;
import com.cablelabs.log.PC2LogCategory;
import com.cablelabs.log.LogAPI;
import com.cablelabs.tools.SIPLocator;
import com.cablelabs.utility.UtilityEvent;

/**
 * This is the interface between the platform engine 
 * (application layer) and the SIP protocol stack. 
 * All communication between the test platform and an
 * external network element utilizing the SIP protocol
 * must occur through this class.
 * 
 * It allows the SIP Stack to be created, started and
 * to remain running in between test executions.
 * 
 * @author ghassler
 *
 */

public class SIPDistributor implements Distributor, SipListener, GinRegistration {

	/**
	 * The SIP Factory 
	 */
	private static SipFactory sipFactory = null;

	/**
	 * The SIP Stack's Address Factory
	 */
	private static AddressFactory addressFactory;

	/**
	 * The SIP Stack's Message Factory
	 */
	private static MessageFactory messageFactory;

	/**
	 * The SIP Stack's Header Factory
	 */
	private static HeaderFactory headerFactory;

	/**
	 * Mapping from name to PC2SipStack
	 */
	private ConcurrentHashMap<String, PC2SipStack> sipStacks = new ConcurrentHashMap<String, PC2SipStack>();

	/**
	 * Mapping from ip to PC2SipStack
	 */
	private ConcurrentHashMap<String, LinkedList<PC2SipStack>> ipToStacks = new ConcurrentHashMap<String, LinkedList<PC2SipStack>>();


	/**
	 * The manufacturer for creating SIP message
	 * generated by the platform engine
	 */
	private SIPManufacturer manufacturer;

	/**
	 * The inspector performs all automated message validation
	 * defined for the SIP protocol that is identified in 
	 * Appendix B of the SIP-ATP.
	 */
	private static SIPInspector inspector = SIPInspector.getInstance();

	/**
	 * A handle to the settings container.
	 */
	private static SystemSettings ss = SystemSettings.getInstance();

	/**
	 * A table that defines what request messages have been received 
	 * by the platform. The key for this table is callId
	 * // -cSeqNo-method
	 */
	//private static HashSet<String> requestsTable = new HashSet<String>();
	private static Hashtable<String, Request> requestsTable = new Hashtable<String, Request>();

	/**
	 * A table that defines what final response messages have been received 
	 * by the platform. The key for this table is callId
	 *  // -cSeqNo-method
	 */
	//private static HashSet<String> responsesTable = new HashSet<String>();
	private static Hashtable<String, Response> responsesTable = new Hashtable<String, Response>();

	/**
	 *  A table to hold the gin registration's IP address and the contact header
	 */
	private static Hashtable<String, String> ginContactTable = new Hashtable<String, String>();

	/**
	 * The logger for the class.
	 */
	private LogAPI logger = LogAPI.getInstance();

	/**
	 * A random number generator for constructing
	 * toTag parameter.
	 */
	static private Random rand = null;
	
	/**
	 * The string used to separate each part of the key
	 */
	static private String keySeparator = ";;";

	/**
	 * This table holds information that is used throughout a call flow with a peer
	 * network element. This includes such information as the SipStack being used 
	 * to communicate with the device. The SipProvider that is performing the exchange,
	 * the transport protocol (UDP, TCP, TLS) that is being used to convey the message
	 * exchange as well as other information. The key for the table is 
	 * <localTag>;;<remoteTag>;;<callId>.
	 * 
	 * The need for the key comprising so many different elements is due to the fact
	 * that the platform may receive the same request multiple times as it progress
	 * through the DUT depending on the test scenario and the various network elements
	 * that the platform is attempting to emulate.
	 * 
	 * The rules for detemining whether the To tag is the local or remote Tag are 
	 * based upon whether the SIP message is a request or response and whether it
	 * is being sent or received The rules are as follows:
	 * 
	 * if (request && sending)
	 * 		localTag = From tag
	 * 		remoteTag = To tag
	 * else if (request && receiving) 
	 * 		localTag = To tag
	 * 		remoteTag = From tag
	 * else if (response && sending)
	 * 		localTag = To tag
	 * 		remotetag = From tag
	 * else if (response && receiving)
	 * 		localTag = From tag
	 * 		remoteTag = To tag
	 * 
	 */
	private ConcurrentHashMap<String, PC2SipData> db = new ConcurrentHashMap<String, PC2SipData>();

	/**
	 * The subcategory to use when logging
	 * 
	 */
	static final protected String subCat = "Distributor";

	private SIPLocator locator = SIPLocator.getInstance();
	/**
	 * Constructor.
	 *
	 */
	public SIPDistributor() {
		rand = new Random();
	}

	/**
	 * This method attempts to locate a given callId in the database using 
	 * each stacks localAddress and port as the key.
	 * 
	 * @param respEvent - The SIP Response message and information from the stack.
	 * @return
	 */
	private PC2SipData callIdUsedOnDifferentAddressAndPort(ResponseEvent respEvent) {
		PC2SipData sipData = null;
		boolean found = false;
		Enumeration<PC2SipStack> e = sipStacks.elements();
		SipProvider provider = null;
		//		String key = null;
		while (e.hasMoreElements() && !found) {
			PC2SipStack p = e.nextElement();
			String transport = "UDP";
			// We need to look at each provider within the stack
			for (int i = 0; i < 3 && !found; i++) {
				provider = p.getProvider(transport);
				if (provider != null) {
					sipData = getSipData(respEvent, provider);
					if (sipData != null)
						found = true;
				}
				if (i == 0 && !found) 
					transport = "TCP";
				else if (i == 1 && !found)
					transport = "TLS";
			}
		}
		
		return sipData;
	}

	/** 
	 * This method is used to notify the SIP stack for clearing 
	 * any internal data between tests.
	 *
	 */
	public void clear() {
		requestsTable.clear();
		responsesTable.clear();
		ginContactTable.clear();
		inspector.clear();
		db.clear();
	}

	/**
	 * Creates a tag for a SIP Header
	 */
	static public String createTag() {
		Integer tag = rand.nextInt();
		if (tag < 0)
			tag *= -1;
		return tag.toString();
	}

	/**
	 * This method tests whether a new Request is a duplicate of a 
	 * preceeding Request message.
	 * 
	 * @param event
	 * @return
	 */

	/**
	 * This method tests whether a new Request is a duplicate of a 
	 * preceeding Request message.
	 * 
	 * @param event
	 * @return
	 */
	private boolean duplicateRequest(String key, String method, Request req) {
		Request prev = requestsTable.get(key);
		if (prev != null && prev.equals(req))
			return true;
		else {
			requestsTable.put(key, req);
			logger.debug(PC2LogCategory.SIP, subCat, "Adding " + method + " to Request table.");
		}
		return false;
	}

	/**
	 * This method tests whether a new final Response (200-699) is a duplicate of a 
	 * previous final Response message.
	 * 
	 * @param event
	 * @return
	 */
	private boolean duplicateResponse(String key,  int statusCode, String method, Response resp) {
		Response prev = responsesTable.get(key);
		if (prev != null && prev.equals(resp))
			return true;
		else {
			responsesTable.put(key, resp);
			logger.debug(PC2LogCategory.SIP, subCat, "Adding " + statusCode + "-" + method + " to Responses table.");
			return false;
		}
	}

	private String filterURI(String uri) {
		//		 Remove any leading uri type information
		String pui = null;
		boolean lookPort = true;
		if (uri == null)
			return null;

		if (uri.startsWith("urn:")) {
			pui = uri.substring(4);
			lookPort = false;
		}
		else if (uri.startsWith("sip:") || 
				uri.startsWith("tel:"))
			pui = uri.substring(4);
		else if (uri.startsWith("sips:"))
			pui = uri.substring(5);
		else 
			pui = uri;
		int offset = 0;
		// remove any trailing parameters
		if (pui.contains(";")) {
			offset = pui.indexOf(";");
			pui = pui.substring(0, offset);
		}
		// Now filter the pui for any port information
		if (pui != null) {
			if (lookPort) {
				// We need to determine if the message is 
				// an IPv6 address or not before removing
				// the port
				int brace = pui.indexOf("[");
				if (brace == -1) {
					int colon = pui.indexOf(":");
					if (colon != -1) {
						pui = pui.substring(0,colon);
					}
				}
				else {
					brace = pui.indexOf("]", brace+1);
					if (brace != -1) 
						pui = pui.substring(0, brace+1);
				}
			}
			if (pui != null) {
				int plus1 = pui.indexOf("+");
				if (plus1 != -1) {
					plus1++;
					// PEERING - remove stripping of 1 from phone number
					if (pui.charAt((plus1)) == '1') {
						pui = pui.substring((plus1+1));
					}
					else 
						pui = pui.substring(plus1);
				}
				// Remove any leading 1 if it is a phone number
				// PEERING - remove stripping of 1 from phone number
				else if (pui.charAt(0) == '1' && 
						!pui.contains(".") && !pui.contains(":")) {
					pui = pui.substring(1);
				}
			}
		}

		// Lastly see if this is one of the VSC codes that needs further reduction.
		if (pui != null && pui.startsWith("*69")) {
			int period = pui.indexOf(".");
			if (period != -1)
				pui = pui.substring(0, period);
		}

		return pui;
	}

	private void getAutoRoute(Proxy p) {
		SIPMsg origMsg = p.getSIPMsg();
		if (origMsg != null) {

			String phoneNum = null;
			if (origMsg.isRequestMsg()) {
				Request r = origMsg.getRequest();
				phoneNum = getToURI(r);
			}
			else if (origMsg.isResponseMsg()) {
				Response r = origMsg.getResponse();
				phoneNum = getFromURI(r);
			}

			if (phoneNum != null) {
				Properties prop = ss.getPropertiesByTelephone(phoneNum);
				if (prop != null) {
					String label = prop.getProperty(SettingConstants.NE);
					if (label.startsWith("UE") || label.equals("DUT")) {
						p.setTarget(label);
					}
				}
			}
		}
	}

	private String getClosestIP(String goal, String ip1, String ip2) {
		if (goal == null || goal.length() == 0) return null;
		if (ip1 == null || ip1.length() == 0) return ip2;
		if (ip2 == null || ip2.length() == 0) return ip1;
		if (ip1.equalsIgnoreCase(ip2)) return ip1;

		boolean goalIsIPv6 = Conversion.isIPv6Address(goal);
		boolean ip1IsIPv6 = Conversion.isIPv6Address(ip1);
		boolean ip2IsIPv6 = Conversion.isIPv6Address(ip2);

		if (goalIsIPv6 && ip1IsIPv6 && !ip2IsIPv6) {
			return ip1;
		} else if (goalIsIPv6 && !ip1IsIPv6 && ip2IsIPv6) {
			return ip2;
		} else if (!goalIsIPv6 && !ip1IsIPv6 && ip2IsIPv6) {
			return ip1;
		} else if (!goalIsIPv6 && ip1IsIPv6 && !ip2IsIPv6) {
			return ip2;
		}

		// Both ip1 and ip2 are the same type as the goal, so choose ip1
		return ip1;
	}
	
	private String getFromURI(Response r) {
		FromHeader from = (FromHeader)r.getHeader(FromHeader.NAME);
		String phoneNum = null;
		if (from != null) {
			URI uri = from.getAddress().getURI();
			if (uri != null)
				if (uri.isSipURI()) {
					phoneNum = ((SipURI)uri).getUser();
				}
		}
		return phoneNum;
	}

	/**
	 * This method evaluates whether a device that has registered with the system
	 * supports the GIN registration process and then retrieves the Contact address
	 * to use when sending any requests to the device.
	 * 
	 * @param s - the message to sent that includes the original request.
	 * @param ip - the network elements ip.
	 * @return true if the device uses gin, false otherwise
	 */
	@Override
	public boolean getGinRegistrationInfo(Send s, String ip) {
		Request req = ((SIPMsg)s.getRequest()).getRequest();
		if (req != null && req.getMethod().equals(Request.REGISTER)) {
			String nameAddr = locator.getSIPParameter(ContactHeader.NAME, 
					SIPLocator.ADDR_SPEC, MsgQueue.FIRST , req.toString());
			String requires = locator.getSIPHeader(RequireHeader.NAME, MsgQueue.ANY, req.toString());
			if (requires != null &&
					nameAddr != null &&
					requires.contains("gin") &&
					nameAddr.contains("bnc")) {
				if (nameAddr.contains("@")) {
					logger.error(PC2LogCategory.SIP, subCat, "The Contact Header's address [" 
							+ nameAddr + "] contains the @ symbol.");
				}
				nameAddr = nameAddr.replace(";bnc", "");
				nameAddr = nameAddr.replace("sip:", "");
				String srcIP = ((SIPMsg)s.getRequest()).getSrcIP();
				if (ip.equals(srcIP)) {
					logger.info(PC2LogCategory.SIP, subCat, "Adding contact information [" + nameAddr 
							+ "] for the device at IP address [" + ip + "].");
					ginContactTable.put(ip, nameAddr);
				}
				return true;
			}
		}

		return false;
	}
	/**
	 * This method creates the key for the dialog information when sending
	 * a message to another network element.
	 * 
	 * @param msg - the message to use to obtain the to, from and callID headers.
	 * @param rte - the SIPRoute class information being used to send the message.
	 * @param forProxy - the search for the data is more loose in the case of proxying
	 * 
	 * @return
	 */
	private PC2SipData getSipData(Message msg, SIPRoute rte, boolean forProxy) {
		if (msg != null) {
			String key = null;
			ToHeader to = (ToHeader)msg.getHeader(ToHeader.NAME);
			FromHeader from = (FromHeader)msg.getHeader(FromHeader.NAME);
			String callId = ((CallIdHeader)msg.getHeader(CallIdHeader.NAME)).getCallId();

			if (msg instanceof Request) {

				key = getKey(from.getTag(), to.getTag(), callId);

				logger.debug(PC2LogCategory.SIP, subCat, 
						"Searching for key(" + key + ") in database.");
				if (!db.containsKey(key)) {
					PC2SipData sipData = new PC2SipData(key, rte.provider, getTransport(rte.provider));
					
					sipData.setFromTag(from.getTag());
					sipData.setCallId(callId);
					if (to.getTag() != null)
						sipData.setToTag(to.getTag());
					sipData.setSSInitiated(true);
					db.put(key, sipData);
					logger.info(PC2LogCategory.SIP, subCat, 
							"Adding key(" + key + ") to dialog database");
					return sipData;
				}
			}
			else if (msg instanceof Response) {
				key = getKey(to.getTag(), from.getTag(), callId);

				logger.debug(PC2LogCategory.SIP, subCat, 
						"Searching for key(" + key + ") in database.");
				if (!db.containsKey(key)) {
					logger.info(PC2LogCategory.SIP, subCat,
							"Could not locate SIP dialog information in database for key=("
									+ key + ") when sending Response Event. Trying Local tag set to null.");
					// Try and find it will null as the toTag
					String key2 = getKey(null, from.getTag(), callId);
					logger.debug(PC2LogCategory.SIP, subCat, 
							"Searching for key(" + key2 + ") in database.");
					if (!db.containsKey(key2)) {
						if (forProxy) {
							String loose = to.getTag() + keySeparator + from.getTag();
							Enumeration<String> keys = db.keys();
							boolean match = false;
							while (keys.hasMoreElements()) {
								String temp = keys.nextElement();
								if (temp.startsWith(loose)) {
									match = true;
								}
								if (match)
									return db.get(temp);
							}
							logger.warn(PC2LogCategory.SIP, subCat,
									"Could not locate SIP dialog information in database for loose key=("
											+ loose + ") when receiving Response Event.");
						}
						else {
							logger.warn(PC2LogCategory.SIP, subCat,
									"Could not locate SIP dialog information in database for key=("
											+ key2 + ") when receiving Response Event.");
						}

					}
					else {
						// We need to add the key with the to tag set now to the
						// dialog database.
						PC2SipData sipData = db.get(key2);
						db.put(key, sipData);
						logger.info(PC2LogCategory.SIP, subCat, 
								"Adding key(" + key + ") to dialog database");
					}
				}
			}

			if (key != null)
				return db.get(key);
		}
		return null;
	}

	/**
	 * This method creates the key for the dialog information when receiving
	 * a message from another network element.
	 * 
	 * @param event - the message event to use to obtain the to, from and callID headers.
	 * @param rte - the SIPRoute class information being used to send the message.
	 * @return
	 */
	private PC2SipData getSipData(EventObject event, SipProvider sipProvider) {
		Message msg = null;

		if (event instanceof RequestEvent) {
			msg = ((RequestEvent)event).getRequest();
		}
		else if (event instanceof ResponseEvent) {
			msg = ((ResponseEvent)event).getResponse();
		}

		if (msg != null) {
			String key = null;
			ToHeader to = (ToHeader)msg.getHeader(ToHeader.NAME);
			FromHeader from = (FromHeader)msg.getHeader(FromHeader.NAME);
			String callId = ((CallIdHeader)msg.getHeader(CallIdHeader.NAME)).getCallId();
			if (msg instanceof Request) {
				String toTag = to.getTag();

				key = getKey(toTag, from.getTag(), callId);
				logger.debug(PC2LogCategory.SIP, subCat, "Searching for key(" + key + ") in database.");
				
				if (!db.containsKey(key)) {
					PC2SipData sipData = new PC2SipData(key, callId, sipProvider, from.getTag(), getTransport(sipProvider));
					sipData.setRequestContact(msg.toString());
					sipData.setToTag(toTag);
					db.put(key, sipData);
					logger.info(PC2LogCategory.SIP, subCat, 
							"Adding key(" + key + ") to dialog database");
				}
			}
			else if (msg instanceof Response) {
				// There is a special condition when we receive a response.
				// The dialog forming request's To tag will be null as
				// well as a 100-Trying so it is originally added to the
				// database using null as the tag value. When any response
				// with a to tag set to it, it needs to be added to the 
				// database with the same dialog information.
				String toTag = to.getTag();
				if (toTag == null) {
					key = getKey(from.getTag(), to.getTag(), callId);
				} else {
					key = getKey(from.getTag(), to.getTag(), callId);
					logger.debug(PC2LogCategory.SIP, subCat, "Searching for key(" + key + ") in database.");
					if (!db.containsKey(key)) {
						logger.info(PC2LogCategory.SIP, subCat,
								"Could not locate SIP dialog information in database for key=("
										+ key + ") when receiving Response Event. Trying Remote tag set to null.");
						// Try and find it will null as the toTag
						String key2 = getKey(from.getTag(), null, callId);
						logger.trace(PC2LogCategory.SIP, subCat, 
								"Searching for key(" + key2 + ") in database.");
						if (!db.containsKey(key2)) {
							logger.warn(PC2LogCategory.SIP, subCat,
									"Could not locate SIP dialog information in database for key=("
											+ key2 + ") when receiving Response Event.");
						}
						else {
							// We need to add the key with the to tag set now to the
							// dialog database.
							PC2SipData sipData = db.get(key2);
							db.put(key, sipData);
							logger.info(PC2LogCategory.SIP, subCat, "Adding key(" + key + ") to dialog database");
						}
					}
				}

				if (!(db.containsKey(key))) {
					String key2 = this.getFlippedDialogKey(key);
					if (!db.containsKey(key2)) {
						logger.warn(PC2LogCategory.SIP, subCat,
							"Could not locate SIP dialog information in database for key=("
									+ key + ") when receiving Response Event.");
					} else {
						key = key2;
					}
				}
			}

			if (key != null) {
				return db.get(key);
			}
		}
		return null;
	}

	/**
	 * Constructs the key for the data in the db attribute for consistent access of the
	 * data. The reason for all of the elements is that we may want to test calls
	 * to and from the same platform for a single dialog but have the traffic go
	 * between two different stacks or possibly the same stack. Also the same dialog
	 * may arrive at the platform many times depending upon what network element it
	 * is emulating during the test.
	 * 
	 @param localTag - this is the to or from tag depending on whether the message is
	 * 			being received or sent by the platform and whether it is a response
	 * 			or a request message.
	 * @param remoteTag - this is the to or from tag depending on whether the message is
	 * 			being received or sent by the platform and whether it is a response
	 * 			or a request message.
	 * @param callId - the call id of the SIP dialog.
	 * 
	 * @return
	 */
	private String getKey(String localTag, String remoteTag, String callId) {
//		if (localTag == null) {
//			@SuppressWarnings("unused")
//			int brkpt = 0;
//		}
		
		String key = localTag + keySeparator + remoteTag + keySeparator + callId;
		return key;
	}
	
	/**
	 * Gets the dialog key with the from and to tags flipped
	 * @return
	 */
	public String getFlippedDialogKey(String dialogKey) {
		String parts[] = dialogKey.split(SIPDistributor.keySeparator);
		if (parts.length != 3) {
			logger.fatal(PC2LogCategory.SIP, subCat, "Found malformed dialogKey(" + dialogKey + ")");
		}
		return parts[1] + SIPDistributor.keySeparator + parts[0] + SIPDistributor.keySeparator + parts[2];
	}

	/**
	 * Calculates the src Network Element label to use to
	 * generate a request 
	 */
	private String getSourceLabel(Send s, NetworkElements nes) {
		if (s.getOriginator() != null) 
			return s.getOriginator();
		else if (nes.getTargetsSize() > 0) 
			return nes.getTargets().next();
		else
			return null;
	}

	private PC2SipStack getSipStackByType(boolean ipV6) {
		// Next we need to identify the default stack for this global registrar
		Properties platform = SystemSettings.getSettings(SettingConstants.PLATFORM);
		try {
			int stacks = Integer.parseInt(platform.getProperty(SettingConstants.NUM_SIP_STACKS));
			String foundStack = null;
			for (int i = 1; i<= stacks; i++) {
				String name = platform.getProperty("SIP Stack " + i + " Name");
				Properties p = SystemSettings.getSettings(name);
				String stackIP = p.getProperty("javax.sip.IP_ADDRESS");
				if (Conversion.isIPv6Address(stackIP) == ipV6) {
					foundStack = name;
					break;
//					if (foundStack == null)
//						foundStack = name;
//					else {
//						// There are two stacks with the same ip type, which stack to use is undefined
//						return null;
//					}
				}
			}
			if (foundStack == null)
				return null;
			else
				return sipStacks.get(foundStack);
		}
		catch (NumberFormatException nfe) {
			logger.fatal(PC2LogCategory.PCSim2, subCat, "The SIP Number of Stacks setting in the platform configuration file does not appear to be a number.");
			
		}
		
		return null;
	}
	
	private PC2SipStack getProxyStackToUse(String msgStack, String fsmStack, String defStack, PC2SipStack originStack, String targetNE) {
		PC2SipStack out = null;
		
		if (msgStack != null && sipStacks.get(msgStack) != null) {
			out = sipStacks.get(msgStack);
        }
	    else if (fsmStack != null && sipStacks.get(fsmStack) != null) {
	    	out = sipStacks.get(fsmStack);
	    } else if (originStack != null ) {
	    	out = originStack;
	    	Properties targetProps = SystemSettings.getSettings(targetNE);
	    	if (targetProps == null) {
	    		logger.error(PC2LogCategory.SIP, subCat, "Target(" + targetNE
	    				+ ") does not appear to have settings defined in the platform configuration file.");
	    	} else {
	    		String targetIP = targetProps.getProperty(SettingConstants.IP);

	    		boolean origIsIPv6 = Conversion.isIPv6Address(originStack.getIP());
	    		boolean targetIsIPv6 = Conversion.isIPv6Address(targetIP);
	    		if (origIsIPv6 == targetIsIPv6) {
	    			out = originStack;
	    		}
	    		else if (!origIsIPv6 && targetIsIPv6) {
	    			out = getSipStackByType(true);
	    		}
	    		else if (origIsIPv6 && !targetIsIPv6) {
	    			out = getSipStackByType(false);
	    		}
	    	}
	    }
		
		if (out == null && defStack != null) {
			out = sipStacks.get(defStack);
        }
		
		return out;
	}

	private PC2SipStack getStackToUse(String msgStack, String fsmStack, String defStack, String originator, String target, String destination, String transport) {
		logger.debug(PC2LogCategory.SIP, subCat, "calling getStackToUse(" + msgStack 
				+ ", " + fsmStack + ", " + defStack + ", " + originator + ", " + destination + ", " + transport + ").");
		
		PC2SipStack result = null;
		
		if (msgStack != null && sipStacks.get(msgStack) != null) {
			result = sipStacks.get(msgStack);
        }
	    else if (fsmStack != null && sipStacks.get(fsmStack) != null) {
	    	result = sipStacks.get(fsmStack);
	    }
	    
		if (destination == null && target != null)
			destination = target;
		
		if (destination != null && result == null) {
			if (destination.equals("DUT") || destination.startsWith("UE") || Character.isDigit(destination.charAt(0))) {
	    			// Try to identify the stack for this target by
	    			// Getting the ips of the PCSCF this target uses,
	    			// the ip that is the same version (ipv4/ipv6) as the targets is
	    			// the ip of the stack that should be used.

	    			Properties destProps = SystemSettings.getSettings(destination);
	    			if (destProps == null) {
	    				logger.error(PC2LogCategory.SIP, subCat, "Destination(" + destination
	    						+ ") does not appear to have settings defined in the platform configuration file.");
	    			} else {
	    				String destIP = destProps.getProperty(SettingConstants.IP);

	    				// Get the PCSCFs properties that the target uses
	    				String destP = destProps.getProperty(SettingConstants.PCSCF);
	    				Properties pProps = SystemSettings.getSettings(destP);
	    				if (pProps == null) {
	    					logger.error(PC2LogCategory.SIP, subCat, "PCSCF(" + destP+ ") of destination(" + destination +
	    							") does not appear to have settings defined in the platform configuration file.");
	    				} else {
	    					String pcscfIP = null;//pProps.getProperty(SettingConstants.IP);

	    					pcscfIP = getClosestIP(destIP, pProps.getProperty(SettingConstants.IP), pProps.getProperty(SettingConstants.IP2));
	    					
	    					LinkedList<PC2SipStack> lst = ipToStacks.get(pcscfIP);
	                        if (lst != null) {
	                            if (lst.size() == 1) {
	                                result = lst.getFirst();
	                            } else {
	                                // loop over all the stacks with the correct ip and choose one with the
	                                // correct port
	                                String portStr = null;
	                                if (transport.equals(SettingConstants.UDP)) {
	                                    portStr = pProps.getProperty(SettingConstants.UDP_PORT);
	                                } else if (transport.equals(SettingConstants.TCP)) {
	                                    portStr = pProps.getProperty(SettingConstants.TCP_PORT);
	                                } else if (transport.equals(SettingConstants.TLS)) {
	                                    portStr = pProps.getProperty(SettingConstants.TLS_PORT);
	                                }
	                                
	                                int port = 0;
	                                if (portStr != null) {
	                                    try {
	                                        port = Integer.parseInt(portStr);
	                                    } catch (NumberFormatException e) {
	                                        logger.error(PC2LogCategory.SIP, subCat, "PCSCF (" + destP + ") does not have a valid "+ transport +" port(" + portStr + ")");
	                                    }
                                    }
	                                
	                                if (port > 0) {
	                                    for (PC2SipStack aSipStack : lst){
	                                        if (aSipStack.getLocalPort(transport) == port) {
	                                            result = aSipStack;
	                                            break;
	                                        }
	                                    }
	                                }
	                                
	                            }
	                        }
	    				}
	    			}
	    	}
	    	else if (destination.startsWith("PCSCF")) {
	    		
	    		Properties origProps = SystemSettings.getSettings(originator);
	    		if (origProps == null) {
	    			logger.error(PC2LogCategory.SIP, subCat, "Originator(" + originator+ ") does not appear to have settings defined in the platform configuration file.");
	    		} else {
	    			String originIP = origProps.getProperty(SettingConstants.IP);
	    			Properties pProps = SystemSettings.getSettings(destination);
	    			if (pProps == null) {
	    				logger.error(PC2LogCategory.SIP, subCat, "PCSCF(" + destination +
	    						") does not appear to have settings defined in the platform configuration file.");
	    			} else {
	    				String pcscfIP = null;//pProps.getProperty(SettingConstants.IP);

	    				pcscfIP = getClosestIP(originIP, pProps.getProperty(SettingConstants.IP), pProps.getProperty(SettingConstants.IP2));
	    				LinkedList<PC2SipStack> lst = ipToStacks.get(pcscfIP);
	    				if (lst != null) {
	    				    if (lst.size() == 1) {
	    				        result = lst.getFirst();
	    				    } else {
                                // loop over all the stacks with the correct ip and choose one with the
                                // correct port
                                String portStr = null;
                                if (transport.equals(SettingConstants.UDP)) {
                                    portStr = pProps.getProperty(SettingConstants.UDP_PORT);
                                } else if (transport.equals(SettingConstants.TCP)) {
                                    portStr = pProps.getProperty(SettingConstants.TCP_PORT);
                                } else if (transport.equals(SettingConstants.TLS)) {
                                    portStr = pProps.getProperty(SettingConstants.TLS_PORT);
                                }
                                
                                int port = 0;
                                if (portStr != null) {
                                    try {
                                        port = Integer.parseInt(portStr);
                                    } catch (NumberFormatException e) {
                                        logger.error(PC2LogCategory.SIP, subCat, "PCSCF (" + destination + ") does not have a valid "+ transport +" port(" + portStr + ")");
                                    }
                                }
                                
                                if (port > 0) {
                                    for (PC2SipStack aSipStack : lst){
                                        if (aSipStack.getLocalPort(transport) == port) {
                                            result = aSipStack;
                                            break;
                                        }
                                    }
                                }
	    				        
	    				    }
	    				}
	    			}
	    		}
	    	}
	    	else {
	    		logger.warn(PC2LogCategory.SIP, subCat, "'" + destination + "' is of an unexpected target type");
	    	}
	    }
		
		if (result == null && defStack != null) {
			result = sipStacks.get(defStack);
        }
		
		logger.debug(PC2LogCategory.SIP, subCat, "getStackToUse returning " + (result == null ? "null" : result.getName()));
		
		return result;
	}

	private String getToURI(Request r) {
		ToHeader to = (ToHeader)r.getHeader(ToHeader.NAME);
		String phoneNum = null;
		if (to != null) {
			URI uri = to.getAddress().getURI();
			if (uri != null)
				if (uri.isSipURI()) {
					phoneNum = ((SipURI)uri).getUser();
				}
		}
		return phoneNum;
	}

	private String getToURI(Response r) {
		ToHeader to = (ToHeader)r.getHeader(ToHeader.NAME);
		String phoneNum = null;
		if (to != null) {
			URI uri = to.getAddress().getURI();
			if (uri != null)
				if (uri.isSipURI()) {
					phoneNum = ((SipURI)uri).getUser();
				}
		}
		return phoneNum;
	}

	/**
	 * Returns the username portion of the Request-URI
	 * @return - either the username or phone number of 
	 * 		the Request-URI;
	 */
	private String getUserName(URI uri) {
		String username = null;
		try {

			if (uri.isSipURI())
				username = ((SipURI)uri).getUser();
			else if (uri instanceof TelURL) 
				username = ((TelURL)uri).getPhoneNumber();
			else if (uri instanceof GenericURI)
				username = ((GenericURI)uri).toString();
		}
		catch (ClassCastException cce) {

		}
		return username;
	}


	/**
	 * Gets the stacks Address Factory
	 * 
	 */
	public static AddressFactory getAddressFactory() {
		return addressFactory;
	}

	/**
	 * Gets the stacks Header Factory
	 */
	public static HeaderFactory getHeaderFactory() {
		return headerFactory;
	}

	/**
	 * Gets the stacks Message Factory
	 */
	public static MessageFactory getMessageFactory() {
		return messageFactory;
	}

	/**
	 * This method provides a common view of the listening
	 * sockets opened in the stack for processing during
	 * this series of tests.
	 */
	@Override
	public String getStackAddresses() {
		return getStackAddresses(false);
	}

	/**
	 * This method provides a common view of the listening
	 * sockets opened in the stack for processing during
	 * this series of tests.
	 */
	public String getStackAddresses(boolean includeStackName) {
		String result = "";
		if (sipStacks != null && sipStacks.size() > 0) {
			Enumeration<PC2SipStack> stacks = sipStacks.elements();
			while (stacks.hasMoreElements()) {
				PC2SipStack ps = stacks.nextElement();
				// We next need to get the IP and port information
				// for each of the possible transport protocols that the
				// stack may have created.
				String ip = ps.getLocalAddress(SettingConstants.UDP);
				int port = ps.getLocalPort(SettingConstants.UDP);
				if (ip != null && port != -1) {
					result += ((includeStackName) ? (ps.getName() + " ") : "") 
							+ "SIP " + Transport.UDP.toString() + " " + ip + "|" 
							+ port + "\n";
				}
				ip = ps.getLocalAddress(SettingConstants.TCP);
				port = ps.getLocalPort(SettingConstants.TCP);
				if (ip != null && port != -1) {
					result += ((includeStackName) ? (ps.getName() + " ") : "")
							+ "SIP " + Transport.TCP.toString() + " " + ip + "|" + port + "\n";
				}
				ip = ps.getLocalAddress(SettingConstants.TLS);
				port = ps.getLocalPort(SettingConstants.TLS);
				if (ip != null && port != -1) {
					result += ((includeStackName) ? (ps.getName() + " ") : "")
							+ "SIP " + Transport.TLS.toString() + " " + ip + "|" + port + "\n";
				}
			}

		}
		return result;
	}

	private Transport getTransport(SipProvider p) {
		String tp = p.getListeningPoint().getTransport();
		if (tp.equalsIgnoreCase(Transport.UDP.toString()))
			return Transport.UDP;
		else if (tp.equalsIgnoreCase(Transport.TCP.toString()))
			return Transport.TCP;
		else if (tp.equalsIgnoreCase(Transport.TLS.toString()))
			return Transport.TLS;
		return null;
	}

	/**
	 * This method contains the rules for determining if a 
	 * response should include the SDP body automatically
	 * or not.
	 * @param statusCode - the status code of the response.
	 * @param method - the method type of the original dialog request.
	 * @param s - the message information used to construct the message.
	 * @param req - the original dialog creating request.
	 * @param sipData - the dialog information maintained by the distributor.
	 * @return - true if the SDP is to be included, false otherwise.
	 */
	private boolean includeSDP(int statusCode, String method, Send s, Request req,
			PC2SipData sipData) {

		// First see if the send includes a multipart body or not 
		if (s.getIncludeMultipartBody())
			return false;
		boolean includeSDP = s.getIncludeSDP();
		// Determine if the response should include SDP automatically
		ContentTypeHeader cth = (ContentTypeHeader)req.getHeader(ContentTypeHeader.NAME);
		ContentDispositionHeader cdh = (ContentDispositionHeader)req.getHeader(ContentDispositionHeader.NAME);

		logger.debug(PC2LogCategory.SIP, subCat, "SIPDistributor req parameter is " + req);

		if (method.equalsIgnoreCase("Invite")) {
			if (statusCode == 183) {
				includeSDP = true;
				logger.debug(PC2LogCategory.SIP, subCat,
						"SIPDistributor setting includeSDP=true because method=INVITE and statusCode=183");
			}
			else if (statusCode == 200) {
				SIPMsg origReq = (SIPMsg)s.getRequest();
				if (origReq.getEvent() == SIPConstants.REINVITE) {
					includeSDP = true;
					logger.debug(PC2LogCategory.SIP, subCat,
							"SIPDistributor setting includeSDP=true because method=INVITE and statusCode=200");
				}
				else if (req != null) {
					SupportedHeader sh = (SupportedHeader)req.getHeader(SupportedHeader.NAME);
					if (sh != null) {
						String supported = sh.toString();
						if (!supported.contains("100rel") && !supported.contains("precondition")) {
							includeSDP = true;
							logger.debug(PC2LogCategory.SIP, subCat,
									"SIPDistributor setting includeSDP=true because method=INVITE and Supported header doesn't contain both 100rel and precondition\"");
						}
						else if (!sipData.sentSDPAnswer()) {
							includeSDP = true;
							logger.debug(PC2LogCategory.SIP, subCat,
									"SIPDistributor setting includeSDP=true because SDP has not been answered");
						}
						else {
							boolean rel = supported.contains("100rel");
							boolean pre = supported.contains("precondition");
							logger.debug(PC2LogCategory.SIP, subCat,
									"SIPDistributor setting includeSDP=false because Supported header=" 
											+ supported + " rel=" + rel + " pre=" + pre);
						}
					}
					else if (!sipData.sentSDPAnswer()) {
						includeSDP = true;
						logger.debug(PC2LogCategory.SIP, subCat,
								"SIPDistributor setting includeSDP=true because SDP has not been answered");
					}
					else 
						logger.debug(PC2LogCategory.SIP, subCat,
								"SIPDistributor setting includeSDP=false because Supported header is missing");
				}
			}
			else 
				logger.debug(PC2LogCategory.SIP, subCat,
						"SIPDistributor setting includeSDP=false because the status-code is not 183 or 200.");
		}
		else if (method.equalsIgnoreCase("Prack") && 
				statusCode == 200 && !sipData.getSSInitiated() &&
				cth != null && cth.getContentSubType().equals(MsgRef.SDP_MSG_TYPE) &&
				(cdh == null || cdh.getDispositionType() != "early-session")) {
			includeSDP = true;
			logger.debug(PC2LogCategory.SIP, subCat,
					"SIPDistributor setting includeSDP=true because method=PRACK, status-code=200 and media-subType=\"sdp\"");
		}
		else if (method.equalsIgnoreCase("Update") && 
				statusCode == 200 && 
				cth != null && cth.getContentSubType().equals(MsgRef.SDP_MSG_TYPE)) {
			includeSDP = true;
			logger.debug(PC2LogCategory.SIP, subCat,
					"SIPDistributor setting includeSDP=true because method=UPDATE, status-code=200 and media-subType=\"sdp\"");
		}
		else 
			logger.debug(PC2LogCategory.SIP, subCat,
					"SIPDistributor setting includeSDP=false because method=" + method);

		logger.info(PC2LogCategory.SIP, subCat, 
				"SIPDistributor calcultated that includeSDP=" + includeSDP
				+ "\n method=" + method + " status-code=" + statusCode + " sentSDPAnswer=" 
				+ (!sipData.sentSDPAnswer()));
		return includeSDP;
	}
	/**
	 * Class constructor and initializer for the 
	 * underlying SIP stack
	 *
	 */
	public void init() {
		logger.trace(PC2LogCategory.SIP, subCat, "Initializing SIP stack and Distribution.");
		sipFactory = SipFactory.getInstance();
		sipFactory.setPathName("gov.nist");
		String name = null;

		try {
			boolean stackCreated = false;

			Properties platform = SystemSettings.getSettings(SettingConstants.PLATFORM);
			int stacks = Integer.parseInt(platform.getProperty(SettingConstants.NUM_SIP_STACKS));
			for (int i = 1; i <= stacks; i++) {
				name = platform.getProperty("SIP Stack " + i + " Name");
				if (name != null) {
					Properties sip = SystemSettings.getSettings(name);
					if (sip != null) {
						if (!stackCreated) {
							headerFactory = sipFactory.createHeaderFactory();
							addressFactory = sipFactory.createAddressFactory();
							messageFactory = sipFactory.createMessageFactory();
							stackCreated = true;
						}
						PC2SipStack sipStack = new PC2SipStack(sipFactory, this, sip); 
						sipStacks.put(name, sipStack);
						String stkIP = sipStack.getIP().trim();
						
						// If stkIP is ipv6 then add both the ip and [ip] to the map
						if (Conversion.isIPv6Address(stkIP)) {
							if (stkIP.startsWith("[")) {
								stkIP = stkIP.substring(1);
							} 
							
							if (stkIP.endsWith("]")) {
								stkIP.substring(0, stkIP.length()-1);
							}
							
							LinkedList<PC2SipStack> lst = null;
							if ((lst = ipToStacks.get("[" + stkIP + "]")) == null) {
							    lst = new LinkedList<PC2SipStack>();
							    ipToStacks.put("[" + stkIP + "]", lst);
							}
							lst.add(sipStack);
						}
						
						LinkedList<PC2SipStack> lst = null;
                        if ((lst = ipToStacks.get(stkIP)) == null) {
                            lst = new LinkedList<PC2SipStack>();
                            ipToStacks.put(stkIP, lst);
                        }
                        lst.add(sipStack);
					}

				}
				else if (name == null) {
					logger.error(PC2LogCategory.SIP, subCat, 
							"SIPDistributor could not find the SIP Stack " + i 
							+ " Name property value in the Platform Settings file.");
				}
			}
			if (!stackCreated) {
				shutdown();
				return;
			}
			else {
				logger.info(PC2LogCategory.SIP, subCat,
						"SIP Distributor has started " + stacks 
						+ " protocol stacks.\n" + getStackAddresses(true));

			}


			// As a safety check make sure that the provider required in the
			// settings has been created successfully
			String transport = platform.getProperty(SettingConstants.SIP_DEF_TRANPORT_PROTOCOL);
			String defStack = platform.getProperty(SettingConstants.SIP_DEF_STACK_NAME);
			String port = platform.getProperty(defStack + " " + transport.toUpperCase() + " Port");
			if (transport == null ||
					port == null || 
					sipStacks.get(defStack) == null) {
				logger.fatal(PC2LogCategory.SIP, subCat, 
						"SIPDistributor detected did not start " 
								+ transport + "!!! Test may not operate as expected.");
			}

			manufacturer = new SIPManufacturer();

		} 
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, 
					"Failed to create SIP Stack (" + name + ")" + ex.getMessage(), ex);
		}
	}


	/**
	 * This is the initial callout from the SIP stack when it
	 * receives a Request message that is valid and not a 
	 * retransmission.
	 */
	@Override
	public void processRequest(RequestEvent requestEvent) {
		Request request = requestEvent.getRequest();
		
		FSMListener listener = null;
		SipProvider sipProvider = (SipProvider) requestEvent.getSource();
		String peerAddress = requestEvent.getPeerAddress();
		int peerPort = requestEvent.getPeerPort();
		String localAddress = sipProvider.getListeningPoint().getHost();
		int localPort = sipProvider.getListeningPoint().getPort();
		String callId = ((CallIdHeader)request.getHeader(CallIdHeader.NAME)).getCallId();
		String toTag = ((ToHeader)request.getHeader(ToHeader.NAME)).getTag();

		logger.trace(PC2LogCategory.SIP, subCat, 
				"SIPDistributor rcvd a " + request.getMethod() 
				+ " request message\n[" + request + "]");


		String listenerKey = null;
		boolean registrarListener = false;

		boolean invite = false;
		String reqMethod = request.getMethod();
		//		if (reqMethod.equalsIgnoreCase("ACK")) {
		//			int glh = 0;
		//		}
		PC2SipData sipData = getSipData(requestEvent, sipProvider);
		boolean duplicate = duplicateRequest(callId, reqMethod, request);

		if (sipData != null &&
				sipData.getProvider() != null &&
				sipProvider != sipData.getProvider()) {
			if (sipProvider != sipData.getProvider())
				logger.error(PC2LogCategory.SIP, subCat, 
						"SIPDistributor received a request message from an unexpected provider [sipProvider != sipData's provider]." 
								+ " Dropping packet -\n["
								+ request + "]");
			return;
		}
		else if (sipData == null){
			{
				logger.fatal(PC2LogCategory.SIP, subCat, 
						" we shouldn't be getting here!!!! sipData == null");
			}
			return;

		}
		listener = sipData.getListener();

		String uri = null;
		String pui = null;
		RouteHeader routeHdr = (RouteHeader)request.getHeader(RouteHeader.NAME);
		boolean regOperation = false;
		boolean usedRequestURI = false;
		boolean presenceReq = false;
		String subscribeType = null;

		if (reqMethod.equals(Request.REGISTER)) {
			FromHeader from = (FromHeader)request.getHeader(FromHeader.NAME);
			uri = from.getAddress().getURI().toString();
			regOperation = true;
		}
		else if (reqMethod.equals(Request.SUBSCRIBE)) {
			EventHeader eh = (EventHeader)request.getHeader(EventHeader.NAME);
			if (eh != null) {
				subscribeType = eh.getEventType();
				if (subscribeType.equals(SettingConstants.SUBSCRIBE_TYPE_UA_PROFILE) ||
						subscribeType.equals(SettingConstants.SUBSCRIBE_TYPE_MSG_SUMMARY) ||
						subscribeType.equals(SettingConstants.SUBSCRIBE_TYPE_REG)) {
					FromHeader from = (FromHeader)request.getHeader(FromHeader.NAME);
					uri = from.getAddress().getURI().toString();
					regOperation = true; 
				}
				else if (subscribeType.equals(SettingConstants.SUBSCRIBE_TYPE_PRESENCE)) {
					uri = getUserName(request.getRequestURI());
					usedRequestURI = true;
					presenceReq = true;
				}
				else if (subscribeType.equals(SettingConstants.SUBSCRIBE_TYPE_DIALOG)) {
					if (routeHdr != null) {
						uri = routeHdr.getAddress().getURI().toString();
					}
					else {
						ToHeader to = (ToHeader)request.getHeader(ToHeader.NAME);
						uri = getUserName(to.getAddress().getURI());
					}
				}

			}
		}
		else if (reqMethod.equals(Request.PUBLISH)) {
			EventHeader eh = (EventHeader)request.getHeader(EventHeader.NAME);
			if (eh != null) {
				String type = eh.getEventType();
				if (eh.getEventType().equals(SettingConstants.SUBSCRIBE_TYPE_PRESENCE)) {
					uri = getUserName(request.getRequestURI());
					usedRequestURI = true;
					presenceReq = true;
				}
				else if (type.equals("vq-rtcpxr")) {
					uri = routeHdr.getAddress().getURI().toString();
				}
			}	
		}
		else if (routeHdr != null) {
			if (reqMethod.equals(Request.INVITE))
				invite = true;
			uri = routeHdr.getAddress().getURI().toString();
		}
		else {
			if (reqMethod.equals(Request.INVITE))
				invite = true;
			uri = getUserName(request.getRequestURI());
			usedRequestURI = true;
		}
		if (uri != null) {
			pui = filterURI(uri);
			if (listener == null) {
				if (regOperation) {
					listenerKey = Stacks.getRegistrarKey(PC2Protocol.SIP, localAddress, pui);
					listener = Stacks.getRegistrarListener(PC2Protocol.SIP, localAddress, pui);
					registrarListener = true;
				}
				else if (presenceReq) {
					listenerKey = pui;
					listener = Stacks.getPresenceServer();
				}
				else {
					listenerKey = pui;
					listener = Stacks.getSessionListener(PC2Protocol.SIP, listenerKey);
				}
				sipData.setListener(listener);
			}

			// Because the test environment might be FSM1 simulating UE1, PCSCF1 & SCSCF1
			// and FMS2 simulating UE2, PCSCF1 & SCSCF1, we might need to perform a second
			// lookup for a session listener using the Request-URI if the message
			// used Route Header first
			if (!usedRequestURI && !regOperation && listener == null) {
				String listenerType = null;
				if (registrarListener)
					listenerType = "Registrar Listener Table";
				else
					listenerType = "Session Listener Table";

				String origListenerKey = listenerKey;
				uri = getUserName(request.getRequestURI());
				pui = filterURI(uri);

				listenerKey = pui;
				logger.info(PC2LogCategory.SIP, subCat, 
						"Could not find listener for key=" + origListenerKey + " in " 
								+ listenerType + ". Trying Request-URI[" + listenerKey + "].");
				listener = Stacks.getSessionListener(PC2Protocol.SIP, listenerKey);
				sipData.setListener(listener);
			}

			try {
				if (sipData != null && listener != null) {
					SIPMsg msg = null;
					if (invite && toTag != null && !duplicate) {
						msg = new SIPMsg(listener.getFsmUID(), System.currentTimeMillis(), 
								requestEvent.getSequencer(), 
								sipData.getDialogKey(), sipData.getTransport(), 
								peerAddress, peerPort, localAddress, localPort, request, 
								request.toString(), subscribeType, SIPConstants.REINVITE, new Boolean(false));
						// Since this is an INVITE that is apart of an existing dialog
						// clear the sentSDPAnswer flag in the data
						sipData.setSentSDPAnswer(false);
						// Next since this is a reinvite, see if the contact port has
						// changed and update it 
						sipData.setPeerPort(request);
						logger.info(PC2LogCategory.SIP, subCat, 
								"SIP Distributor is using the port[" + sipData.getPeerPort() 
								+ "] to communicate for the dialog defined by callid[" + callId + "].");
					}
					else
						msg = new SIPMsg(listener.getFsmUID(), System.currentTimeMillis(),
								requestEvent.getSequencer(), sipData.getDialogKey(),
								sipData.getTransport(),
								peerAddress, peerPort, localAddress, localPort, 
								request, request.toString(), subscribeType, new Boolean(false));

					MsgQueue q = PCSim2.getMsgQueue();
					boolean insideDialog = false;
					boolean initiatedDialog = false;
					boolean dialogFormingRequest = false;
					String origReq = null;
					String origToTag = null;
					// We need to save the To tag and identify whether this dialog
					// was initiated by the SS or not for future processing.
					if (reqMethod.equals(Request.INVITE) ||
							reqMethod.equals(Request.SUBSCRIBE) ||
							reqMethod.equals(Request.REFER)) {
						SIPMsg origMsg = q.findByCallId(listener.getFsmUID(), callId);
						if (origMsg != null && 
								// If the toTag is null, it could be an INVITE redirected from a
								// 302 response which should be treated as a new request
								toTag != null) {
							// Since we have a previous INVITE or SUBSCRIBE with this callId
							// This new Request should be inside the dialog
							insideDialog = true;

							if (origMsg.hasSentMsg())
								origReq = origMsg.getSentMsg();
							else 
								origReq = origMsg.getRequest().toString();

							if (sipData != null)
								initiatedDialog = sipData.getSSInitiated();

							if (initiatedDialog && invite) 
								origToTag = locator.getSIPParameter(FromHeader.NAME, "tag", MsgQueue.FIRST, origReq);
							else
								origToTag = sipData.getToTag();

							if (invite && sipData != null)
								sipData.setSSInitiated(initiatedDialog);
						}
						else {
							// Since we didn't find a dialog, this is an original Request for the dialog
							// It should be a new dialog request since it is an INVITE, SUBSCRIBE
							// or REFER
							dialogFormingRequest = true;
							// Next since this is a dialog creating request set the peer port
							sipData.setPeerPort(request);
							logger.info(PC2LogCategory.SIP, subCat, 
									"SIP Distributor is using the port[" + sipData.getPeerPort() 
									+ "] to communicate for the dialog defined by callid[" + callId + "].");

						}
					}
					else {
						ToHeader to = (ToHeader)request.getHeader(ToHeader.NAME);
						if (sipData != null && sipData.getToTag() == null)
							sipData.setToTag(to.getTag());
						origToTag = sipData.getToTag();
						initiatedDialog = sipData.getSSInitiated();	
					}

					// Determine if this new request is inside or outside an existing dialog 
					if (!dialogFormingRequest) {
						if (reqMethod.equals(Request.OPTIONS) ||
								reqMethod.equals(Request.PUBLISH)) {
							SIPMsg origMsg = q.findByCallId(listener.getFsmUID(), callId);
							if (origMsg != null ) {
								// Since we have a previous INVITE or SUBSCRIBE with this callId
								// This new Request should be inside the dialog
								insideDialog = true;
								if (origMsg.hasSentMsg())
									origReq = origMsg.getSentMsg();
								else 
									origReq = origMsg.getRequest().toString();
							}
						}
						else if (reqMethod.equals(Request.BYE)) {
							// When it is a BYE message we need to make sure that a REINVITE didn't occur
							SIPMsg origMsg = (SIPMsg)q.find(listener.getFsmUID(), "REINVITE", 
									MsgQueue.LAST, listener.getCurrentMsgIndex());
							if (origMsg == null) {
								origMsg = q.findByCallId(listener.getFsmUID(), callId);
								if (origMsg != null) {
									if (origMsg.hasSentMsg())
										origReq = origMsg.getSentMsg();
									else 
										origReq = origMsg.getRequest().toString();
								}
							}
							else {
								if (origMsg.hasSentMsg())
									origReq = origMsg.getSentMsg();
								else 
									origReq = origMsg.getRequest().toString();
							}
						}
						// Any request besides a MESSAGE and REGISTER should be inside a dialog and 
						// need to have the insideDialog flag set.
						else if (!reqMethod.equals(Request.MESSAGE) &&
								!reqMethod.equals(Request.REGISTER)) {
							SIPMsg origMsg = q.findByCallId(listener.getFsmUID(), callId);
							// A CANCEL request is not within a dialog
							if (origMsg != null && !reqMethod.equals(Request.CANCEL)) {
								// Since we have a previous INVITE or SUBSCRIBE with this callId
								// This new Request should be inside the dialog
								insideDialog = true;
								if (origMsg.hasSentMsg())
									origReq = origMsg.getSentMsg();
								else 
									origReq = origMsg.getRequest().toString();
							}

						}
					}
					// Now perform validation of the common procedures by calling the inspector
					boolean invalid = false;
					if (!duplicate)
						invalid = inspector.inspect(request, insideDialog, 
								sipData.isIntegrityProtected(), 
								origReq, origToTag, initiatedDialog,
								sipData.getResponseContact(),
								sipData.getRespRecordRouteHeaders(),
								sipData);
					if (ss.useInspector() && invalid) {
						PCSim2.setTestPassed(false);
						logger.fatal(PC2LogCategory.SIP, subCat, 
								"Inspector declaring test case failure.");
					}
					else if (ss.useInspector()) {
						logger.info(PC2LogCategory.SIP, subCat, 
								"Inspectors result are currently affecting test results.");
					}

					// Test message for duplicate transmission
					if (duplicate) {
						logger.info(PC2LogCategory.SIP, subCat, 
								"SIPDistributor detected duplicate " + reqMethod + " request message");
					}
					msg.setDuplicate(duplicate);
					listener.processEvent(msg);
					//					if (listener.processEvent(msg) && !duplicate)
					//						addRequest(requestKey);

					logger.info(PC2LogCategory.SIP, subCat, 
							" Delivered " + reqMethod + " request to FSM(" + listener.getFSMName() 
							+ ") for processing:\n");

				}
				else {
					String listenerType = null;
					if (registrarListener)
						listenerType = "Registrar Listener Table";
					else
						listenerType = "Session Listener Table";
					logger.warn(PC2LogCategory.SIP, subCat, 
							"Could not find listener for key=" + listenerKey + " in " 
									+ listenerType + ". Dropping message event.");
				}
			} 
			catch ( Exception ex) {
				logger.warn(PC2LogCategory.SIP, subCat, 
						"Exception occurred while processing SIP request message.", ex);
			}

		}
		else {
			logger.warn(PC2LogCategory.SIP, subCat, 
					"Could not determine what value to use to locate the FSM to " +
							"deliver the event. Dropping " + reqMethod + " message event.");
		}
	}

	/**
	 * This is the initial callout from the SIP stack when it 
	 * receives a response message that is valid, has a
	 * corresponding ClientTransaction and is part of a 
	 * dialog.
	 */
	@Override
	public void processResponse(ResponseEvent responseEvent) {
		Response response = responseEvent.getResponse();
		int statusCode = response.getStatusCode();

		logger.trace(PC2LogCategory.SIP, subCat, 
				"SIPDistributor rcvd a response message\n["
						+ response + "]");
		String peerAddress = responseEvent.getPeerAddress();
		int peerPort = responseEvent.getPeerPort();
		SipProvider sipProvider = (SipProvider)responseEvent.getSource();
		String localAddress = sipProvider.getListeningPoint().getHost();
		int localPort = sipProvider.getListeningPoint().getPort();

		String callId = ((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId();
		CSeqHeader cs = (CSeqHeader)response.getHeader(CSeqHeader.NAME);
		String respMethod = cs.getMethod();
		int cSeqNo = cs.getSequenceNumber();
		boolean duplicate = duplicateResponse(callId, statusCode, respMethod, response);

		// For looking up the dialog information we need to switch the receive
		// and transmit information from that of the request

		PC2SipData sipData = getSipData(responseEvent, sipProvider);

		if (sipData == null) {
			sipData = callIdUsedOnDifferentAddressAndPort(responseEvent);
		}
		String method = null;
		if (sipData != null) {
			FSMListener listener = sipData.getListener();
			if (listener != null) {
				SIPMsg origReq = listener.findByCallIdAndMethod(callId, respMethod, cSeqNo);
				method = Integer.toString(statusCode) + "-" + respMethod;

				if (origReq != null) {
					SIPMsg msg = new SIPMsg(listener.getFsmUID(), System.currentTimeMillis(),
							responseEvent.getSequencer(), sipData.getDialogKey(),
							sipData.getTransport(),
							peerAddress, peerPort, localAddress, localPort, 
							response, response.toString(), new Boolean(false));  

					if (sipData != null && sipData.getToTag() == null &&
							(statusCode > Response.TRYING  &&
									(respMethod.equals(Request.INVITE) || respMethod.equals(Request.REGISTER)))) {
						ToHeader to = (ToHeader)response.getHeader(ToHeader.NAME);
						sipData.setToTag(to.getTag());
						logger.trace(PC2LogCategory.SIP, subCat, 
								"Setting toTag in original request to the value=" + to.getTag());
					}


					String inspectReq = null;
					// Now find the correct Request message
					if (origReq.hasSentMsg())
						inspectReq = origReq.getSentMsg();
					else 
						inspectReq = origReq.getRequest().toString();
					logger.info(PC2LogCategory.SIP, subCat,
							"Inspector was matched to Sequencer=" + origReq.getSequencer()); 


					if ((respMethod.equals(SIPConstants.INVITE) ||
							respMethod.equals(SIPConstants.SUBSCRIBE) ||
							respMethod.equals(SIPConstants.REFER)) &&
							!origReq.getEventName().equals(SIPConstants.REINVITE)) {
						if (statusCode > 100) {
							if (sipData.getResponseContact() == null) {
								sipData.setResponseContact(response.toString());
								logger.debug(PC2LogCategory.SIP, subCat, "" +
										"Assigning " + sipData.getResponseContact() 
										+ " for dialog dialog defined by " + sipData.getDialogKey());
							}

							if (statusCode >= 200) {
								sipData.setFinalResponse(statusCode);
							}

							if (sipData.getPeerPort() == -1) {
								sipData.setPeerPort(response);
								logger.info(PC2LogCategory.SIP, subCat, 
										"SIP Distributor is using the port[" + sipData.getPeerPort() 
										+ "] to communicate for the dialog defined by callid[" + callId + "].");
							}
						}
					}

					boolean invalid = false;
					if (!duplicate)
						invalid = inspector.inspect(response, 
								inspectReq, true, false, sipData);
					if (ss.useInspector() && invalid) {
						PCSim2.setTestPassed(false);
						logger.fatal(PC2LogCategory.SIP, subCat, 
								"Inspector declaring test case failure.");
					}
					// Test message for duplicate transmission
					if (duplicate)
						logger.info(PC2LogCategory.SIP, subCat, 
								"SIPDistributor detected duplicate " + method + " final response message.");
					msg.setDuplicate(duplicate);
					listener.processEvent(msg);

					logger.info(PC2LogCategory.SIP, subCat, 
							" Delivered response(" + method + ") to FSM(" 
									+ listener.getFSMName() 
									+ ") for processing");
				}
				else {
			
					SIPMsg msg = new SIPMsg(listener.getFsmUID(), System.currentTimeMillis(),
							LogAPI.getSequencer(), sipData.getDialogKey(),
							sipData.getTransport(),
							peerAddress, peerPort, localAddress, localPort, response, null, new Boolean(false));
					boolean invalid = inspector.inspect(response, null, true, false, sipData);
					if (ss.useInspector() && invalid) {
						PCSim2.setTestPassed(false);
						logger.fatal(PC2LogCategory.SIP, subCat, 
								"Inspector declaring test case failure.");
					}
					listener.processEvent(msg);

					logger.info(PC2LogCategory.SIP, subCat, 
							" Delivered " + method + " response to fsm(" + listener.getFSMName() + "-" + listener.getFsmUID() + ") for processing:\n");

				}
			}
		}
	}

	/**
	 * Provides a callout for the SIP Stack when a request fails to receive
	 * a response after having retransmitted the maximum number of message.
	 */
	@Override
	public void processTimeout(javax.sip.TimeoutEvent timeoutEvent) {
		logger.debug(PC2LogCategory.SIP, subCat, 
				"SIP Transaction Time out" );
		logger.debug(PC2LogCategory.SIP, subCat, 
				"TimeoutEvent " + timeoutEvent.getTimeout());
	}


	/**
	 * The interface for transmitting a SIP message generated by the 
	 * platform engine. The engine provides the FSM's unique ID 
	 * a list of network elements currently supported.
	 * 
	 * @param fsm - the FSMListener requesting the SIP message to
	 * 				be sent.
	 * @param p - the Proxy class describing the message to construct
	 * @param nes - a definition of the network elements the engine is
	 *              currently simulating.
	 * @param fsmStack - the name of the FSM stack to use
	 * 
	 * @return - the SIP message that was created and sent by the platform
	 */
	public SIPMsg proxy(FSMListener fsm, Proxy p, NetworkElements nes, String fsmStack) {
		SIPMsg origMsg = p.getSIPMsg();
		Properties platform = SystemSettings.getSettings(SettingConstants.PLATFORM);
		String defTransport = platform.getProperty(SettingConstants.SIP_DEF_TRANPORT_PROTOCOL);
		String defStack = platform.getProperty(SettingConstants.SIP_DEF_STACK_NAME);
		// These variables were added to allow improved processing when
		// the tool is being used for System testing
		boolean autoRouting = false;
		String callId = null;
		
		
		
		if (origMsg.isResponseMsg() && origMsg.getResponse().getStatusCode() == 100) {
			@SuppressWarnings("unused")
			int glh=0;
		}
			
		// Next get the PC2SipStack and SipProvider to use
		PC2SipStack sipStack = null;
		
		PC2SipData origSipData = db.get(( origMsg.isRequestMsg() ? origMsg.getDialogKey() : getFlippedDialogKey(origMsg.getDialogKey()) ));
		SipStack origSipStack = origSipData.getStack();
		PC2SipStack origMsgStack = (origSipData!=null ? sipStacks.get(origSipStack.getStackName()) : null);
		if (origMsg.isResponseMsg())
			sipStack = origMsgStack;
		else
			sipStack = getProxyStackToUse(p.getStack(), fsmStack, defStack, origMsgStack, p.getTarget());
				
		if (sipStack != null) {
			SipProvider provider = sipStack.getProvider(p.getTransport(), defTransport);
			
			
			String name = null;
			PC2SipData sipData = null;
			String key = null;
			try {
				Message proxyMsg = null;
				SIPRoute rte = null;
				
				if (origMsg.isRequestMsg()) {
					String src = p.getOriginator();
					
					FromHeader from = (FromHeader)origMsg.getRequest().getHeader(FromHeader.NAME);
					String phoneNum = ((SipURI)from.getAddress().getURI()).getUser();
					Properties ue = SystemSettings.getPropertiesByPhoneNumber(phoneNum);

					if (ue != null)
						src = ue.getProperty(SettingConstants.NE);
					
					// Determine if the system should auto route the message
					if (p.getTarget().equals("auto")) {
						autoRouting = true;
						getAutoRoute(p);
					}
					
					rte = new SIPRoute(sipStack, provider, p, src, 
							getTransport(provider));
					
					Request request = origMsg.getRequest();
					// GLH RTCP ISSUE
					if (autoRouting) {
						Object body = request.getContent();
						if (body != null && body instanceof String) {
							String sdp = (String)body;
							sdp = sdp.replaceFirst("a=rtcp: ", "a=rtcp:");
							ContentTypeHeader cth = (ContentTypeHeader)request.getHeader(ContentTypeHeader.NAME);
							request.setContent(sdp, cth);
							
						}
					}
					sipData = getSipData(request, rte, true);
					if (sipData != null && sipData.getListener() == null) {
						sipData.setListener(fsm);
					}
					
					if (p.getTarget() == null &&
							request.getRequestURI().isSipURI()) {
						SipURI reqURI = (SipURI)request.getRequestURI();
						name = reqURI.getUser();
						if (name != null ) {
							rte.targetNE = name;
							rte.target = SystemSettings.getSettings(name);
						}
						else {
							String ip = reqURI.getHost();
							Properties target = SystemSettings.getPropertiesByIP(ip,"UE");
							if (target != null) {
								rte.targetNE = target.getProperty(SettingConstants.USER_NAME);
								rte.target = target;
							}
						}
						rte.refresh();
					}
					
					
					if (rte.src != null && rte.target != null) {
						String contactAddr = ginContactTable.get(rte.peerAddress);
						proxyMsg = manufacturer.updateRequest(rte, request, 
								nes, sipData, contactAddr);
					}
					else {
						logger.warn(PC2LogCategory.SIP, subCat, 
								"SIPDistributor failed to locate target[" 
								+ rte.targetNE + "] or src[" 
								+ rte.srcNE + "] property information.");
					}
					
				}
				else if (origMsg.isResponseMsg()) {
					Response response = origMsg.getResponse();
					// GLH RTCP ISSUE
					if (autoRouting) {
						Object body = response.getContent();
						if (body != null && body instanceof String) {
							String sdp = (String)body;
							sdp = sdp.replaceFirst("a=rtcp: ", "a=rtcp:");
							ContentTypeHeader cth = (ContentTypeHeader)response.getHeader(ContentTypeHeader.NAME);
							response.setContent(sdp, cth);
							
						}
					}
					proxyMsg = manufacturer.updateResponse(response, nes);
					String src = p.getOriginator();
					
					if (src == null) {
						if (p.getTarget().equals("auto")) {
							String phoneNum = getToURI(response);
							if (phoneNum != null) {
								Properties prop = ss.getPropertiesByTelephone(phoneNum);
								if (prop != null) {
									String label = prop.getProperty(SettingConstants.NE);
									if (label.startsWith("UE") || label.equals("DUT")) {
										src = label;
									}
								}
								getAutoRoute(p);
								autoRouting = true;
								int status = response.getStatusCode();
								CSeqHeader cs = (CSeqHeader)response.getHeader(CSeqHeader.NAME);
								String respMethod = cs.getMethod();
								if (status == 200 && respMethod.equals(SIPConstants.BYE)) {
									callId = ((CallIdHeader)response.getHeader(CallIdHeader.NAME)).getCallId();
								}
							}
						}
						else {
							src = nes.getTargets().next();
						}
					}
										
					rte = new SIPRoute(sipStack, provider, p, src, getTransport(provider));
					// Any message that is expected to be proxied should have been received
					// by the platform and should therefore have an entry in the database
					sipData = getSipData(response, rte, true);
					
					
					if (sipData == null) {
						logger.error(PC2LogCategory.SIP, subCat, 
								"SIPDistributor could not locate key(" + key + ") in protocolTable and providerTable.");
					}
				}
				
				if (proxyMsg != null && 
						sipData != null && 
						rte != null &&
						rte.peerAddress != null && 
						rte.peerPort > 0) {
					
					String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
							p.getModifiers(), proxyMsg, p.isCompact());
					
					// Send the response message
					int seq = LogAPI.getSequencer();
					provider.sendMessage(modMsg, seq, rte.peerAddress, 
							rte.peerPort, rte.transport.toString());
					
					SIPMsg msg = null;
					if (proxyMsg instanceof Request) {
						msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
								seq, key, rte.transport,
								rte.localAddress, rte.localPort, 
								rte.peerAddress, rte.peerPort, 
								(Request)proxyMsg, modMsg, null, new Boolean(true));
						if (sipData.getCallId() == null)
							key = updateSipData((Request)proxyMsg, sipData, rte, false);
					}
					else if (proxyMsg instanceof Response)
						msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
								seq, key, rte.transport,
								rte.localAddress, rte.localPort, 
								rte.peerAddress, rte.peerPort, 
								(Response)proxyMsg, modMsg, new Boolean(true));
					
					// In case the proxy instance is used again reset the target back
					// to "auto" after use
					if (autoRouting) {
						p.setTarget("auto");
						if (callId != null) {
							String dbKey = sipData.getDialogKey();
							db.remove(dbKey);
							requestsTable.remove(callId);
							responsesTable.remove(callId);
						}
					}
					logger.trace(PC2LogCategory.SIP, subCat, 
							"SIPDistributor sent\n[" 
							+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
					return msg;
				}
				else {
					logger.warn(PC2LogCategory.SIP, subCat, "Unable to locate Network Label[" + name + "] to proxy message." );
				}
			}
			catch (Exception ex) {
				logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(), ex);
				ex.printStackTrace();
			}
		}
		return null;
	}

	public SIPMsg retransmit(FSMListener fsm, Retransmit r, SIPMsg sipMsg, NetworkElements nes, 
			UtilityMsg lastUtilMsg, String fsmStack) {
		String key = sipMsg.getDialogKey();

		if (key != null)
			db.get(key);
		try {
			SipProvider provider = null;
			Transport t = null;

			Properties platform = SystemSettings.getSettings(SettingConstants.PLATFORM);
			String defTransport = platform.getProperty(SettingConstants.SIP_DEF_TRANPORT_PROTOCOL);
			String defStack = platform.getProperty(SettingConstants.SIP_DEF_STACK_NAME);

			String trans = defTransport;
			if (r.getTransportProtocol() != null) {
			    trans = r.getTransportProtocol();
			}
			// Next get the PC2SipStack and SipProvider to use
			PC2SipStack sipStack = getStackToUse(r.getStack(), fsmStack, defStack, r.getOriginator(), r.getTarget(), r.getDestination(), trans);
			if (sipStack != null) {
				provider = sipStack.getProvider(null, 
						defTransport);
				t = getTransport(provider);
			}

			Request req = sipMsg.getRequest();
			Response resp = sipMsg.getResponse();
			String modMsg = null;
			if (sipMsg.hasSentMsg()) {
				modMsg = sipMsg.getSentMsg();
				modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						r.getModifiers(), req, false);
			}
			else if (req != null)
				modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						r.getModifiers(), req, false);
			else if (resp != null)
				modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						r.getModifiers(), resp, false);

			if (modMsg != null) {
				String ip = null;
				int port = -1;

				if (r.getDestination() != null) {
					Properties target = SystemSettings.getSettings(r.getDestination());
					if (target != null) {
						ip = target.getProperty(SettingConstants.IP);
						port = Integer.parseInt(target.getProperty(t.toString().toUpperCase()+ "Port"));
					}
				}
				else{
					ip = sipMsg.getDestIP();
					port = sipMsg.getDestPort();

				}

				int seq = LogAPI.getSequencer();
				provider.sendMessage(modMsg, seq, ip, port, t.toString());

				SIPMsg msg = null;
				if (req != null)
					msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
							seq, key, t,
							provider.getListeningPoint().getHost(), 
							provider.getListeningPoint().getPort(), ip, port, 
							req, modMsg, sipMsg.getSubscribeType(), new Boolean(true));
				else if (resp != null)
					msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
							seq, key, t,
							provider.getListeningPoint().getHost(), 
							provider.getListeningPoint().getPort(), ip, port, 
							resp, modMsg, new Boolean(true));
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + ip + ":" + port);
				if (Conversion.isIPv6Address(provider.getListeningPoint().getHost()) != Conversion.isIPv6Address(ip)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + provider.getListeningPoint().getHost() + ") to(" + ip + ")" );
				}
				return msg;

			}

		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(),ex);
		}
		return null;
	}



	/**
	 * The interface for transmitting a SIP message generated by the 
	 * platform engine. The engine provides the FSM's unique ID 
	 * a list of network elements currently supported.
	 * 
	 * @param fsm - the FSMListener requesting the SIP message to
	 * 				be sent.
	 * @param s - the Send class describing the message to construct
	 * @param nes - a defintion of the network elements the engine is
	 *              currently simulating.
	 * @param lastUtilMsg
	 * @param fsmStack - the SipStack to use for this fsm.
	 * @return - the SIP message that was created and sent by the platform
	 */
	public SIPMsg send(FSMListener fsm, Send s, NetworkElements nes, 
			UtilityMsg lastUtilMsg, String fsmStack) {
		if (s.getProtocol().equalsIgnoreCase(MsgRef.SIP_MSG_TYPE)) {
			
			Properties platform = SystemSettings.getSettings(SettingConstants.PLATFORM);
			String defTransport = platform.getProperty(SettingConstants.SIP_DEF_TRANPORT_PROTOCOL);
			String defStack = platform.getProperty(SettingConstants.SIP_DEF_STACK_NAME);

			// Next get the PC2SipStack and SipProvider to use
			String trans = defTransport;
			if (s.getTransportProtocol() != null) {
			    trans = s.getTransportProtocol().toString();
			}
			
			PC2SipStack sipStack = getStackToUse(s.getStack(), fsmStack, defStack, s.getOriginator(), s.getTarget(), s.getDestination(), trans);
			
			// If there is not a stack specified by the user and If there is an original request stay on that stack
			if (s.getStack() == null && fsmStack == null) {
				if (s.getRequest() != null && s.getRequest() instanceof SIPMsg) {
					SIPMsg origReqst = (SIPMsg)s.getRequest();
				
					if (origReqst != null) {
//						boolean foundOrinalRequestStack = false;
						PC2SipData sipData = db.get(origReqst.getDialogKey());

						if (sipData != null) {
						    PC2SipStack stk = null;
							String stkIP = sipData.getProvider().getSipStack().getIPAddress();
							LinkedList<PC2SipStack> lst = ipToStacks.get(stkIP);
							if (lst != null) {
							    if (lst.size() == 0) {
							        stk = lst.getFirst();
							    } else {
							        ListeningPoint lp = sipData.getProvider().getListeningPoint();
							        logger.debug(PC2LogCategory.LOG_MSG, "", "transport =" + lp.getTransport());
							        String transport = lp.getTransport();
							        int port = lp.getPort();
							        if (transport.equalsIgnoreCase(SettingConstants.UDP)) {
							            for (PC2SipStack aSipStack: lst) {
							                if (port == aSipStack.getLocalPort(SettingConstants.UDP)) {
							                    stk = aSipStack;
							                    break;
							                }
							            }
							        } else if (transport.equalsIgnoreCase(SettingConstants.TCP)) {
							            for (PC2SipStack aSipStack: lst) {
                                            if (port == aSipStack.getLocalPort(SettingConstants.TCP)) {
                                                stk = aSipStack;
                                                break;
                                            }
                                        }
							        } else if (transport.equalsIgnoreCase(SettingConstants.TLS)) {
							            for (PC2SipStack aSipStack: lst) {
                                            if (port == aSipStack.getLocalPort(SettingConstants.TLS)) {
                                                stk = aSipStack;
                                                break;
                                            }
                                        }
							        }
							    }
							}
							if (stk != null) {
								sipStack = stk;
							}
						}
					}
				}
				
			}
			
			
			if (sipStack != null) {
				SipProvider provider = sipStack.getProvider(s.getTransportProtocol(), defTransport);

				if (provider != null) {
					if (SIPConstants.isRequestType(s.getMsgType())) {
						if (SIPConstants.INVITE.equalsIgnoreCase(s.getMsgType())) {
							return sendInvite(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.ACK.equalsIgnoreCase(s.getMsgType())) {
							return sendAck(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.BYE.equalsIgnoreCase(s.getMsgType()) ||
								SIPConstants.CANCEL.equalsIgnoreCase(s.getMsgType()) ||
								SIPConstants.PRACK.equalsIgnoreCase(s.getMsgType()) ||
								SIPConstants.OPTIONS.equalsIgnoreCase(s.getMsgType()) ||
								SIPConstants.UPDATE.equalsIgnoreCase(s.getMsgType())) {
							return sendInterDialogRequest(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}

						else if (SIPConstants.NOTIFY.equalsIgnoreCase(s.getMsgType())) {
							return sendNotify(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.REFER.equalsIgnoreCase(s.getMsgType())) {
							return sendRefer(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.REGISTER.equalsIgnoreCase(s.getMsgType())) {
							return sendRegister(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.PUBLISH.equalsIgnoreCase(s.getMsgType())) {
							return sendPublish(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.SUBSCRIBE.equalsIgnoreCase(s.getMsgType())) {
							return sendSubscribe(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.REINVITE.equalsIgnoreCase(s.getMsgType())) {
							return sendReInvite(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
						else if (SIPConstants.MESSAGE.equalsIgnoreCase(s.getMsgType())) {
							return sendMessage(sipStack, provider, fsm, s, nes, lastUtilMsg);
						}
					}
					else if (SIPConstants.isResponseType(s.getMsgType())) {
						
						return sendResponse(sipStack, provider, fsm.getFsmUID(), s, nes, lastUtilMsg);
					}
				}
				else {
					logger.warn(PC2LogCategory.SIP, subCat,
							"Could not send SIP message because a provider couldn't be found for the values("
									+ s.getTransportProtocol() + "," + defTransport + ").");
				}
			}
			else {
				logger.warn(PC2LogCategory.SIP, subCat,
						"Could not send SIP message because a stack couldn't be found for the values("
								+ s.getStack() + ", " + fsmStack + ", " + defStack + ", " + s.getOriginator() + ", " + s.getTarget() + ").");
			}
		}
		return null;
	}

	private SIPMsg sendAck(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			PC2SipData sipData = null;
			String key = null;
			SIPMsg origReq = (SIPMsg)s.getRequest();
			if (origReq != null) {
				key = origReq.getDialogKey();
				sipData = db.get(key);
				String src = getSourceLabel(s, nes);
				SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));

				if (sipData != null) {
					// Update the route to use the pre-determined port from previous
					// communications for this dialog
					rte.setPeerPort(sipData);
					MsgEvent respEvent = MsgQueue.getInstance().find(fsm.getFsmUID(), "xxx-INVITE", 
							MsgQueue.LAST, fsm.getCurrentMsgIndex());
					if (respEvent != null && respEvent instanceof SIPMsg) {
						Response resp = ((SIPMsg)respEvent).getResponse();
						if (resp != null) {
							Request request = manufacturer.buildAck(s, rte, sipData, origReq.getRequest(), resp, nes);


							if (request != null) {
								String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
										s.getModifiers(), request, s.isCompact());
								int seq = LogAPI.getSequencer();
								provider.sendMessage(modMsg, seq, rte.peerAddress,
										rte.peerPort, rte.transport.toString());

								SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
										seq, key, rte.transport, rte.localAddress, 
										rte.localPort, rte.peerAddress, 
										rte.peerPort, request, modMsg, null, new Boolean(true));
								logger.trace(PC2LogCategory.SIP, subCat, 
										"SIPDistributor sent\n[" 
												+ modMsg + " to " + rte.peerAddress + "|" + rte.peerPort);
								if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
									logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
								}
								return msg;
							}
						}
						else {
							logger.error(PC2LogCategory.SIP, subCat, 
									"SIPDistributor could not find final response to invite message.");
						}
					}
					else {
						logger.warn(PC2LogCategory.SIP, subCat,
								"SIPDistributor could find the last xxx-INVITE in the message queue for FSM(" 
										+ fsm.getFSMName() + ").");
					}
				}
				else {
					logger.error(PC2LogCategory.SIP, subCat, 
							"SIPDistributor could not find the dialog data for to send the ACK message.");
				}
			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(), ex);
		}
		return null;
	}

	private SIPMsg sendInterDialogRequest(PC2SipStack stack, SipProvider provider, 
			FSMListener fsm, Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			// This should be the original dialog forming request (eg. INVITE)
			Request request = null;
			// Source defines the network element creating the message.
			// Target defines to whom the message is to be sent which
			// could be some intermediate network element.
			// Destination defines to whom the message is intended in the end,
			// either the peer end device or application server

			String src = getSourceLabel(s,nes);
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));		

			SIPMsg origReq = (SIPMsg)s.getRequest();
			String key = null;

			PC2SipData sipData = null;
			if (origReq != null) {
				key = origReq.getDialogKey();
				logger.trace(PC2LogCategory.SIP, subCat, "Searching for key(" + key + ") in database.");
				sipData = db.get(key);
			}

			// Make sure the listener is set in our data container
			if (sipData != null && sipData.getListener() == null) 
				sipData.setListener(fsm);

			if (manufacturer != null && SIPConstants.BYE.equalsIgnoreCase(s.getMsgType())) {
				request = manufacturer.buildBye(s, rte, sipData, origReq.getRequest(), nes);
			}
			else if (manufacturer != null && SIPConstants.CANCEL.equalsIgnoreCase(s.getMsgType()))
				request = manufacturer.buildCancel(s, rte, sipData, origReq.getRequest(), nes); 
			else if (manufacturer != null && SIPConstants.PRACK.equalsIgnoreCase(s.getMsgType()))
				request = manufacturer.buildPrack(s, rte, sipData, origReq.getRequest(), nes); 
			else if (manufacturer != null && SIPConstants.OPTIONS.equalsIgnoreCase(s.getMsgType())) {
				if (origReq != null)
					request = manufacturer.buildOptions(s, rte, sipData, origReq.getRequest(), nes);
				else {
					request = manufacturer.buildOptions(s, rte, nes);
					sipData = getSipData(request, rte, false);
					if (sipData != null) {
						sipData.setListener(fsm);
						sipData.getSessionVersion();
					}
				}
			}
			else if (manufacturer != null && SIPConstants.UPDATE.equalsIgnoreCase(s.getMsgType()))
				request = manufacturer.buildUpdate(s, rte, sipData, 
						origReq.getRequest(), nes, s.getIncludeSDP()); 

			if (sipData != null && request != null) {
				String callId = sipData.getCallId();
				// Update the route to use the pre-determined port from previous
				// communications for this dialog
				// PEERING  - remove port set
				//rte.setPeerPort(sipData);

				if (callId == null ) {
					key = updateSipData(request, sipData, rte, false);
				}
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());

				if (sipData.getRequestContact() == null)
					sipData.setRequestContact(modMsg);

				int seq = LogAPI.getSequencer();
				provider.sendMessage(modMsg, seq, rte.peerAddress, rte.peerPort, 
						rte.transport.toString());

				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
						seq, key, rte.transport,
						rte.localAddress, rte.localPort, rte.peerAddress, 
						rte.peerPort, request, modMsg, null, new Boolean(true));
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				return msg;
			}
			else {
				logger.error(PC2LogCategory.SIP, subCat, 
						"SIPDistributor could not locate an entry in the SIP database.");
			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, 
					ex.getMessage(), ex);
			ex.printStackTrace();
		}
		return null;
	}

	private SIPMsg sendInvite(PC2SipStack stack, SipProvider provider, 
			FSMListener fsm, Send s, NetworkElements nes, UtilityMsg utilMsg) {
		// Source defines the network element creating the message.
		// Target defines to whom the message is to be sent which
		// could be some intermediate network element.
		// Destination defines to whom the message is intended in the end,
		// either the peer end device or application server
		try { 
			String src = getSourceLabel(s,nes);
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));


			Request request = manufacturer.buildInvite(s, rte, nes);
			if (request != null) {
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());


				PC2SipData sipData = getSipData(request, rte, false);
				updateSipData(sipData, fsm, modMsg, rte);
				sipData.getSessionVersion();

				int seq = LogAPI.getSequencer();
				rte.provider.sendMessage(modMsg, seq, 
						rte.peerAddress, rte.peerPort, rte.transport.toString());

				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
						seq, sipData.getDialogKey(), rte.transport,
						rte.localAddress, rte.localPort, 
						rte.peerAddress, rte.peerPort, 
						request, modMsg, null, new Boolean(true)); 
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				
				return msg;
			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(),ex);

		}
		return null;
	}

	private SIPMsg sendMessage(PC2SipStack stack, SipProvider provider, 
			FSMListener fsm, Send s, NetworkElements nes, UtilityMsg utilMsg) {
		// Source defines the network element creating the message.
		// Target defines to whom the message is to be sent which
		// could be some intermediate network element.
		// Destination defines to whom the message is intended in the end,
		// either the peer end device or application server
		try { 
			String src = getSourceLabel(s,nes);
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));

			Request request = manufacturer.buildMessage(s, rte, nes);
			if (request != null) {
				//							
				// Make any modifications that the script has defined
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());

				PC2SipData sipData = getSipData(request, rte, false);
				updateSipData(sipData, fsm, modMsg, rte);

				int seq = LogAPI.getSequencer();
				rte.provider.sendMessage(modMsg, seq, 
						rte.peerAddress, rte.peerPort, rte.transport.toString());

				// Create the sent message event
				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
						seq, sipData.getDialogKey(), rte.transport,
						rte.localAddress, rte.localPort, 
						rte.peerAddress, rte.peerPort, 
						request, modMsg, null, new Boolean(true)); 

				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				return msg;
			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(),ex);

		}
		return null;
	}


	private SIPMsg sendNotify(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			boolean notifySubscribe = false;
			boolean notifyRefer = false;
			boolean standAlone = false;
			SIPMsg origReq =  null;
			UtilityEvent utilEvent = null;
			String key = null;
			if (s.getRequest() != null && s.getRequest() instanceof SIPMsg) {
				origReq = (SIPMsg)s.getRequest();
				if (origReq != null) {  
					key = origReq.getDialogKey();
					if (origReq.getRequest().getMethod().equals(SIPConstants.REFER)) 
						notifyRefer = true;
					else if (origReq.getRequest().getMethod().equals(SIPConstants.SUBSCRIBE))
						notifySubscribe = true;
				}
				// If there is not associated request, assume it is for a subscribe
				else {
					notifySubscribe = true;
				}
			}
			else {
				standAlone = true;
			}

			if (notifyRefer || notifySubscribe || standAlone) {
				Request request = null;
				String src = null;
				String target = s.getTarget();
				if (target.equals("DUT")) {
					if (notifySubscribe) {
						Properties dut = SystemSettings.getSettings(target);
						src = dut.getProperty(SettingConstants.PCSCF);
					}
					else if (notifyRefer) {
						String originator = s.getOriginator();
						if (originator == null) {
							ListIterator<String> iter = nes.getTargets();
							boolean done = false;
							while (iter.hasNext() && !done) {
								String ne = iter.next();
								if (ne.startsWith("UE")) {
									originator = ne;
									done = true;
								}

							}
						}
						if (originator != null)
							src = originator;
					}
					else if (standAlone)
						src = getSourceLabel(s,nes);

				}
				else if (target.contains("@")) {
					Properties dut = SystemSettings.getSettings(target);
					src = dut.getProperty(SettingConstants.PCSCF);
				}
				else if (s.getOriginator() != null) {
					src = s.getOriginator();
				}
				else if (target != null) {
					// Assume it is for the registrar processing
					Properties dut = SystemSettings.getSettings(target);
					src = dut.getProperty(SettingConstants.PCSCF);
				}
				SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));
				PC2SipData sipData = null;

				if (src != null && rte.targetNE != null) {
					Byte regId = 1;
					int regVersion = 1;
					String contact = null;
					Request req = null;
					int notifyCount = 0;
					if (origReq != null) {
						rte.peerAddress = origReq.getSrcIP();
						rte.peerPort = origReq.getSrcPort();
						req = origReq.getRequest();
						if (key != null) {
							sipData = db.get(key);
							if (sipData != null) {
								regId = sipData.getRegInfoUniqueId();
								regVersion = sipData.getRegInfoVersion();
								contact = sipData.getRequestContact();
								notifyCount = sipData.getNotifyToReferCount();
							}
						}
						//else {
							// This is likely if we are sending a NOTIFY while operating
							// a test in a proxy
						//}
					}

					// Update the route to use the pre-determined port from previous
					// communications for this dialog
					rte.setPeerPort(sipData);

					String eventType = SettingConstants.SUBSCRIBE_TYPE_REG;
					if (s.getIncludeMessageSummary())
						eventType = "message-summary";

					request = manufacturer.buildNotify(s, rte, sipData,
							contact, fsm.getFsmUID(),
							notifyCount, regId, regVersion, req, nes, 
							utilEvent, eventType, fsm.getCurrentMsgIndex()); 
					String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
							s.getModifiers(), request, s.isCompact());

					if (sipData != null) {
						String callId = sipData.getCallId();
						if (callId == null) {
							key = updateSipData(request, sipData, rte, false);
							sipData.setListener(fsm);
						}
					}
					else {
						sipData = getSipData(request, rte, false);
						sipData.setListener(fsm);
						sipData.setRequestContact(modMsg);
					}

					int seq = LogAPI.getSequencer();
					provider.sendMessage(modMsg, seq, rte.peerAddress, 
							rte.peerPort, rte.transport.toString());

					if (notifyRefer && modMsg != null)
						sipData.incrementNotifyToReferCount();

					SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
							seq, key, rte.transport,
							rte.localAddress, rte.localPort, 
							rte.peerAddress, rte.peerPort, request, modMsg, eventType, new Boolean(true)); 
					logger.trace(PC2LogCategory.SIP, subCat, "SIPDistributor sent\n[" 
							+ modMsg + " to " + rte.peerAddress + ":" 
							+ rte.peerPort);
					if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
						logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
					}
					return msg;
				}
				else {
					logger.warn(PC2LogCategory.SIP, subCat, 
							"SIPDistributor could not send NOTIFY message because the src properties was null.");
				}
			}
			else {
				logger.warn(PC2LogCategory.SIP, subCat, 
						"SIPDistributor could not send NOTIFY message because lastUtilMsg=" + utilMsg);
			}
		}

		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(), ex);
			ex.printStackTrace(); 
		}
		return null;
	}

	private SIPMsg sendPublish(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			Request request = null;
			String src = getSourceLabel(s, nes);
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));

			if (rte != null) { 
				SIPMsg origMsg = (SIPMsg)s.getRequest();
				PC2SipData sipData = null;
				String key = null;
				Request origReq = null;
				if (origMsg != null) {
					key = origMsg.getDialogKey();

					sipData = db.get(key);
					origReq = origMsg.getRequest();
				}	

				// Build the request
				String body = null;
				if (s.getIncludeOpen()) 
					body = "open";
				else if (s.getIncludeClosed())
					body = "closed";

				// Update the route to use the pre-determined port from previous
				// communications for this dialog
				rte.setPeerPort(sipData);

				request = manufacturer.buildPublish(s, rte, 
						origReq, nes, body); 

				//				Make any modifications that script requests
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());

				// Now that we have the new request we need to generate
				// a new entry in the database because this message will have
				// its' own callid.
				if (sipData == null) {
					sipData = getSipData(request, rte, false);
					sipData.setListener(fsm);
					sipData.setRequestContact(modMsg);
				}
				// Update the callId if it is null because we have a new sipData
				else {
					key = updateSipData(request, sipData, rte, false);
					sipData.setListener(fsm);
				}

				// Send the message
				int seq = LogAPI.getSequencer();
				provider.sendMessage(modMsg, seq, rte.peerAddress, 
						rte.peerPort, rte.transport.toString());

				// Create the event for the message queue
				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
						seq, key, rte.transport,
						rte.localAddress, rte.localPort, 
						rte.peerAddress, rte.peerPort, request, modMsg, null, new Boolean(true)); 
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				return msg;

			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(), ex);
			ex.printStackTrace();
		}
		return null;
	}

	private SIPMsg sendRefer(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		String src = getSourceLabel(s,nes);

		if (s.getRequest() != null &&
				s.getRequest() instanceof SIPMsg &&
				((SIPMsg)s.getRequest()).getRequest() != null) {
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));
			SIPMsg origMsg = (SIPMsg)s.getRequest();
			String key = origMsg.getDialogKey();
			PC2SipData sipData = db.get(key);

			Request origReq = origMsg.getRequest();

			try {

				// Update the route to use the pre-determined port from previous
				// communications for this dialog
				rte.setPeerPort(sipData);


				// Build the request
				Request request = manufacturer.buildRefer(s, rte, 
						sipData, origReq, nes); 

				if (request != null) {

					// Make any modifications that the script requests
					String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
							s.getModifiers(), request, s.isCompact());

					sipData = getSipData(request, rte, false);
					updateSipData(sipData, fsm, modMsg, rte);

					// Send the message
					int seq = LogAPI.getSequencer();
					sipData.getProvider().sendMessage(modMsg, seq,
							rte.peerAddress, rte.peerPort, rte.transport.toString());

					// Create the event for the message queue
					SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
							seq, key, rte.transport,
							rte.localAddress, rte.localPort, 
							rte.peerAddress, rte.peerPort, request, modMsg, null, new Boolean(true)); 

					logger.trace(PC2LogCategory.SIP, subCat, 
							"SIPDistributor sent\n[" 
									+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
					if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
						logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
					}
					return msg;
				}

			}
			catch (Exception ex) {
				logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(),ex);

			}
		}
		else {
			logger.error(PC2LogCategory.SIP, subCat,
					"SIPDistributor couldn't send REFER message because " +
							"original request=" + ((SIPMsg)s.getRequest()).getRequest());
		}
		return null;
	}

	private SIPMsg sendRegister(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			Request request = null;

			// Get the property information for the source and target
			// network elements.
			String src = s.getOriginator();
			if (src == null && nes.getUESize() == 1) {
				ListIterator<String> iter = nes.getUEs();
				src = iter.next();
			}
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));

			if (rte.src != null && rte.dest != null) {

				boolean includeDigest = false;


				SIPMsg origReq = (SIPMsg)s.getRequest();

				Request req = null;
				Response prevResp = null;
				PC2SipData sipData = null;
				if (origReq != null) {
					req = origReq.getRequest();
					String key = origReq.getDialogKey();
					sipData = db.get(key);
					MsgQueue q = MsgQueue.getInstance();
					MsgEvent response = q.find(fsm.getFsmUID(), "xxx-REGISTER", 
							MsgQueue.LAST, fsm.getCurrentMsgIndex());
					if (response != null && 
							response instanceof SIPMsg && req != null &&
							response.getMsgQueueIndex() > origReq.getMsgQueueIndex()) {
						// Now test if the response is a 401 or a 200, in which case we want to
						// reuse information from the Authorization header
						SIPMsg sm = (SIPMsg)response;
						if (sm.getEventName().equals("401-REGISTER"))
							prevResp = ((SIPMsg)response).getResponse();
						else if (sm.getEventName().equals("200-REGISTER")) {
							prevResp = ((SIPMsg)response).getResponse();
							// In the case of 200 response we also want to
							// change the origReq variable to be the last
							// Register sent
							//MsgEvent lastReg = q.find(fsm.getFsmUID(), "REGISTER", MsgQueue.LAST);
							//if (lastReg != null && lastReg instanceof SIPMsg) {
							//	req = ((SIPMsg)lastReg).getRequest();
							//} 
						}
					}
				}

				// Update the route to use the pre-determined port from previous
				// communications for this dialog
				rte.setPeerPort(sipData);

				// Build the request
				request = manufacturer.buildRegister(s, rte,  
						fsm.getFsmUID(), req, prevResp, nes, includeDigest, 
						fsm.getCurrentMsgIndex());

				if (sipData == null) {
					sipData = getSipData(request, rte, false);
					sipData.setListener(fsm);
				}


				// Make any modifications that the script requests
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());

				// Send the message
				int seq = LogAPI.getSequencer();
				provider.sendMessage(modMsg, seq, 
						rte.peerAddress, rte.peerPort, rte.transport.toString());

				// Create the event for the message queue						
				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
						seq, sipData.getDialogKey(), rte.transport,
						rte.localAddress, 
						rte.localPort, rte.peerAddress, rte.peerPort, 
						request, modMsg, null, new Boolean(true)); 
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				return msg;
			}

			else if (rte.src == null)
				logger.warn(PC2LogCategory.SIP, subCat, 
						"SIPDistributor can't build Register message because the originator attribute of the send tag is not set.");
			else if (rte.dest == null)
				logger.warn(PC2LogCategory.SIP, subCat, 
						"SIPDistributor can't build Register message because the target attribute of the send tag is not set.");

		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, 
					ex.getMessage(), ex);
			ex.printStackTrace();
		}
		return null;
	}

	private SIPMsg sendReInvite(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		Request origReq = null;
		SIPMsg sm = (SIPMsg)s.getRequest();
		String key = null;
		if (sm != null && 
				sm.getRequest() != null && 
				sm.getRequest() instanceof Request) {
			origReq = sm.getRequest();
			key = sm.getDialogKey();
		}
		if (origReq != null) {
			String src = getSourceLabel(s,nes);

			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));
;
			PC2SipData sipData = null;
			if (key != null)
				sipData = db.get(key);
			if (sipData != null) {
				try {

					// Update the route to use the pre-determined port from previous
					// communications for this dialog
					rte.setPeerPort(sipData);

					// Build the request message
					Request request = manufacturer.buildReInvite(s, rte, sipData, origReq, nes); 

					if (request != null) {

						// Make any modifications that the script requests
						String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
								s.getModifiers(), request, s.isCompact());

						// Send the message
						int seq = LogAPI.getSequencer();
						sipData.getProvider().sendMessage(modMsg, seq, rte.peerAddress, 
								rte.peerPort, rte.transport.toString());

						// Create the event for the message queue
						SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(), 
								seq, key, rte.transport,
								rte.localAddress, rte.localPort, 
								rte.peerAddress, rte.peerPort, 
								request, modMsg, null, SIPConstants.REINVITE, new Boolean(true)); 

						logger.trace(PC2LogCategory.SIP, subCat, 
								"SIPDistributor sent\n[" 
										+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
						if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
							logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
						}
						return msg;
					}
				}
				catch (Exception ex) {
					logger.warn(PC2LogCategory.SIP, subCat, 
							ex.getMessage(),ex);

				}
			}
		}
		return null;
	}
	
	private SIPMsg sendResponse(PC2SipStack stack, SipProvider provider, int fsmUID,
			Send s, NetworkElements nes, UtilityMsg utilMsg) {

		Request request = null;
		SIPMsg origReq = (SIPMsg)s.getRequest();
		String key = null;
		if (origReq != null && 
				origReq.getRequest() != null && 
				origReq.getRequest() instanceof Request) {
			request = origReq.getRequest();
			key = origReq.getDialogKey();
		}

		if (request != null && key != null) {
			try {
				int statusCode = Integer.parseInt(s.getMsgType().substring(0,3));
				String reqMethod = request.getMethod();


				// Get the property information for the source and target
				// network elements.
				String src = getSourceLabel(s, nes);
				SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));
				
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					@SuppressWarnings("unused")
					int brkpt = 0;
				}
				
				if (rte.destNE.equals("DUT")) {
					if (reqMethod.equalsIgnoreCase("Subscribe")) {
						Properties dut = SystemSettings.getSettings("DUT");
						String pcscf = dut.getProperty(SettingConstants.PCSCF);
						rte.src = SystemSettings.getSettings(pcscf);
						rte.target = dut;
					}

				}
				else if (s.getTarget().contains("@")) {
					if (rte.target != null) {
						String pcscf = rte.target.getProperty(SettingConstants.PCSCF);
						rte.src = SystemSettings.getSettings(pcscf); 
					}
				}
				
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					@SuppressWarnings("unused")
					int brkpt = 0;
				}

				rte.refresh();
				
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					@SuppressWarnings("unused")
					int brkpt = 0;
				}
				PC2SipData sipData = db.get(key);

				if (rte.src != null && rte.target != null && sipData != null) {
					String toTag = sipData.getToTag();
					if (toTag == null && 
							statusCode > 100 && statusCode < 700) {
						toTag = createTag();
						sipData.setToTag(toTag);
						// Lastly as we have to finally set the to tag, we
						// need to create a new key for the device and add it
						// to the dialog database.
						String key2 = getKey(sipData.getToTag(), sipData.getFromTag(), sipData.getCallId());
						logger.trace(PC2LogCategory.SIP, subCat, 
								"Searching for key(" + key2 + ") in database.");
						if (!db.containsKey(key2)) {
							db.put(key2, sipData);
							logger.info(PC2LogCategory.SIP, subCat, 
									"Adding key(" + key2 + ") to dialog database");
						}

					}

					logger.debug(PC2LogCategory.SIP, subCat, 
							"Creating response with statusCode=" + statusCode);
					Response response = null;
					boolean addSDP = includeSDP(statusCode, reqMethod, s, request, sipData);

					// Update the route to use the pre-determined port from previous
					// communications for this dialog
					// PEERING - remove port set
					//rte.setPeerPort(sipData);

					// Build the response message
					response = manufacturer.buildResponse(s, rte, 
							sipData, request, nes, statusCode, 
							addSDP);

					if (response != null) {

						// Make any modifications that the script requests
						String modMsg = manufacturer.modifyMessage(fsmUID, 
								s.getModifiers(), response, s.isCompact());

						// Send the message
						int seq = LogAPI.getSequencer();
						provider.sendMessage(modMsg, seq,
								rte.peerAddress, rte.peerPort, rte.transport.toString());
						if (addSDP)
							sipData.setSentSDPAnswer(true);

						if (sipData.getResponseContact() == null) {
							sipData.setResponseContact(modMsg);
							logger.debug(PC2LogCategory.SIP, subCat, "" +
									"Assigning " + sipData.getResponseContact() 
									+ " for dialog dialog defined by " + sipData.getDialogKey());
						}
						if (statusCode > 100) {
							//sipData.getRespRecordRouteHeaders() == null) {
							int [] hdrLocation = locator.locateSIPHeader(RecordRouteHeader.NAME,
									MsgQueue.ANY, modMsg, true, false);
							if (hdrLocation[0] != -1 &&
									hdrLocation[1] != -1 &&
									hdrLocation[2] == SIPLocator.CRLF) {
								sipData.setRespRecordRouteHeaders(modMsg.substring(hdrLocation[0], hdrLocation[1]));
							}
						}
						// Create the event for the message queue
						SIPMsg msg = new SIPMsg(fsmUID, System.currentTimeMillis(),
								seq, key, rte.transport,
								rte.localAddress, rte.localPort, rte.peerAddress, 
								rte.peerPort, response, modMsg, new Boolean(true)); 
						logger.trace(PC2LogCategory.SIP, subCat, 
								"SIPDistributor sent\n[" 
										+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
						if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
							logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
						}
						return msg;

					}
				}
				else {
					if (rte.src == null)
						logger.error(PC2LogCategory.SIP, subCat, "SIPDistributor could not send SIP response message because src NE properties(" 
								+ rte.srcNE + ") could not be located.");
					if (rte.dest == null)
						logger.error(PC2LogCategory.SIP, subCat, "SIPDistributor could not send SIP response message because dest NE properties(" 
								+ rte.destNE + ") could not be located.");
					if (sipData == null)
						logger.error(PC2LogCategory.SIP, subCat, "SIPDistributor could not send SIP response message because sipData (" 
								+ key + ") could not be located.");
				}
			}
			catch (Exception e) {
				logger.warn(PC2LogCategory.SIP, subCat, 
						"Could not send " + s.getMsgType() + " response.", e);
			}

		}
		return null;
	}


	private SIPMsg sendSubscribe(PC2SipStack stack, SipProvider provider, FSMListener fsm, 
			Send s, NetworkElements nes, UtilityMsg utilMsg) {
		try {
			Request request = null;
			// Get the property information for the source and target
			// network elements.
			String src = getSourceLabel(s, nes); // s.getOriginator();
			SIPRoute rte = new SIPRoute(stack, provider, s, src, getTransport(provider));

			if (rte.src != null && rte.target != null) {
				SIPMsg origReq = (SIPMsg)s.getRequest();
				String key = null;
				Request req = null;
				PC2SipData sipData = null;
				if (origReq != null) {
					key = origReq.getDialogKey();
					req = origReq.getRequest();
					sipData = db.get(key);
				}

				// Update the route to use the pre-determined port from previous
				// communications for this dialog
				rte.setPeerPort(sipData);

				// Build the request message
				request = manufacturer.buildSubscribe(s, rte, req, nes, 
						s.getSubscribeType());

				//				Make any modifications that the script requests
				String modMsg = manufacturer.modifyMessage(fsm.getFsmUID(), 
						s.getModifiers(), request, s.isCompact());

				if (sipData == null) {
					sipData = getSipData(request, rte, false);
					updateSipData(sipData, fsm, modMsg, rte);
				}

				int seq = LogAPI.getSequencer();
				provider.sendMessage(modMsg, seq, rte.peerAddress, 
						rte.peerPort, rte.transport.toString());
				//				Create the event for the message queue
				SIPMsg msg = new SIPMsg(fsm.getFsmUID(), System.currentTimeMillis(),
						seq, sipData.getDialogKey(), rte.transport,
						rte.localAddress, rte.localPort, 
						rte.peerAddress, rte.peerPort, 
						request, modMsg, s.getSubscribeType(), new Boolean(true)); 
				logger.trace(PC2LogCategory.SIP, subCat, 
						"SIPDistributor sent\n[" 
								+ modMsg + " to " + rte.peerAddress + ":" + rte.peerPort);
				if (Conversion.isIPv6Address(rte.localAddress) != Conversion.isIPv6Address(rte.peerAddress)) {
					logger.error(PC2LogCategory.SIP, subCat, "Attempting to send to a differ ip type from(" + rte.localAddress + ") to(" + rte.peerAddress + ")" );
				}
				return msg;
			}
			else {
				if (rte.src == null)
					logger.warn(PC2LogCategory.SIP, subCat, 
							"Distributor can't build Subscribe message because the src attribute of the send tag is not set.");
				if (rte.target == null)
					logger.warn(PC2LogCategory.SIP, subCat, 
							"Distributor can't build Subscribe message because the target attribute of the send tag is not set.");
			}
		}
		catch (Exception ex) {
			logger.warn(PC2LogCategory.SIP, subCat, ex.getMessage(), ex);
			ex.printStackTrace();
		}
		return null;
	}
	/**
	 * Allows the SIP Inspector to affect individual tests
	 */
	public void setInspection(boolean flag) {
		inspector.setInspection(flag);
	}

	/**
	 * Used to inform the distributor to shutdown the SIP
	 * stack.
	 *
	 */
	public void shutdown() {
		try {
			clear();
			Enumeration<PC2SipStack> stacks = sipStacks.elements();
			while (stacks.hasMoreElements()) {
				PC2SipStack sipStack = stacks.nextElement();
				logger.info(PC2LogCategory.SIP, subCat, "Shutting down SipStack(" 
						+ sipStack.getName() + ").");
				sipStack.shutdown();
			}
			sipStacks.clear();
			ipToStacks.clear();
			System.gc();
		} 
		catch (Exception ex) { 
			logger.error(PC2LogCategory.SIP, subCat, 
					"SIPDistributor encountered an error while shutting down.\n" 
							+ ex.getMessage() + "\n" + ex.getStackTrace()); 
		}
	}
	private void updateSipData(PC2SipData sipData, FSMListener fsm, String modMsg,
			SIPRoute rte) {
		sipData.setListener(fsm);
		sipData.setRequestContact(modMsg);

		// Now test if we sent different value in the Contact so we can update the key.
		String c = "Contact";
		int [] hdrLocation = locator.locateSIPHeader(c, MsgQueue.FIRST, modMsg, false, false);
		if (hdrLocation[0] != -1 && hdrLocation[1] != -1) {
			int [] paramLocation = locator.locateSIPParameter(c, 
					SettingConstants.PORT, hdrLocation, modMsg);
			if (paramLocation[0] != -1 &&
					paramLocation[1] != -1 &&
					paramLocation[2] != -1) {
				try {
					int temp = Integer.parseInt(modMsg.substring(paramLocation[1], paramLocation[2]));
					if (temp != rte.localPort) {
						// We need to change the sipData entry for this value to 
						String curKey = sipData.getDialogKey();
						String newKey = getKey(sipData.getFromTag(), sipData.getToTag(), sipData.getCallId());
						if (db.containsKey(curKey)) {
							db.remove(curKey);
							logger.info(PC2LogCategory.SIP, subCat, 
									"Removing key(" + curKey + ") from dialog database");
						}
						sipData.setDialogKey(newKey);
						db.put(newKey, sipData);
						logger.info(PC2LogCategory.SIP, subCat, 
								"Adding key(" + newKey + ") to dialog database");
						// Also since the key changed because we are using a different port, 
						// do we need to update the stack and provider to match?
						// TODO -
						// Next get the PC2SipStack and SipProvider to use
						//PC2SipStack sipStack = getStackToUse(s.getStack(), stack);
						//if (sipStack != null) {
						//	SipProvider provider = sipStack.getProvider(s.getTransportProtocol(), 
						//			defTransport);
					}
				}
				catch (NumberFormatException nfe) {
					// Do nothing and leave the db as it is.
				}

			}
		}
	}
	private String updateSipData(Request req, PC2SipData sipData, SIPRoute rte, boolean ssInitiated) {
		if (ssInitiated)
			sipData.setSSInitiated(ssInitiated);
		String callId = ((CallIdHeader)req.getHeader(CallIdHeader.NAME)).getCallId();
		sipData.setCallId(callId);
		String key = sipData.getDialogKey();

		if (!db.containsKey(key)) {
			logger.info(PC2LogCategory.SIP, subCat, 
					"Adding key(" + key + ") to SIP dialog database");
			db.put(key, sipData);
		}
		else {
			logger.error(PC2LogCategory.SIP, subCat, 
					"SIPDistributor attempted to add a new an entry to the database for a key that already existed.");
		}

		return key;
	}

}
